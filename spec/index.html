<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
  <title>RDF 1.2 Semantics</title>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
  <script src="./common/local-biblio.js" class="remove"></script>
  <script src="./common/fixup.js" class="remove"></script>
  <script class='remove'>
    // Use fragment identifier of test as name.
    function data_test_display() {
        const test_references = document.querySelectorAll('details.respec-tests-details a');
        for( const a of test_references ) {
            const href = a.href;
            const test_reference = href.split('#')[1];
            a.textContent = test_reference;
        }
    }

    var respecConfig = {
      localBiblio:          localBibliography,
      specStatus:           "ED",
      edDraftURI:           "https://w3c.github.io/rdf-semantics/spec/",
      testSuiteURI:         "https://w3c.github.io/rdf-tests/rdf/rdf12/",
      shortName:            "rdf12-semantics",
      copyrightStart:       "2004",

      previousPublishDate:  "2014-02-25",
      previousMaturity:     "REC",
      prevRecShortname:     "rdf11-mt",

      editors: [
        { name: "Peter Patel-Schneider", w3cid: "13382"},
        { name: "DÃ¶rthe Arndt", w3cid: "111308"},
        { name: "Enrico Franconi", w3cid: "35616"},
      ],

      formerEditors:  [
        { name: "Patrick J. Hayes" },
      ],

      github: "https://github.com/w3c/rdf-semantics/",
      group:           "rdf-star",
      doJsonLd:     true,
      wgPublicList: "public-rdf-star-wg", 
      xref:   [ "RDF12-CONCEPTS" ],
      postProcess: [data_test_display],

      lint: { "no-unused-dfns": false }
    };
  </script>
  <style>
  .semantictable {background-color: #FFFFAA; padding:0.5em;}
  .ruletable {background-color: #DDDDFF; padding:0.5em;}
  .othertable {background-color: #FDFDFD; padding:0.5em;}
  .tabletitle {font-size: small; font-weight: bolder;}

  .technote {
      font-size:small;
      margin: 2em 0em 0em;
      padding:    1em;
      border: 2px solid #cff6d9;
      background: #e2fff0;
  }

  .technote::before {
      content:    "Technical Note";
      display:    block;
      width:  150px;
      margin: -1.5em 0 0.5em 0;
      font-weight:    bold;
      border: 1px solid #cff6d9;
      background: #eff;
      padding:    3px 1em;
  }



  .fact  {
      padding: 0.5em;
      margin: 1em 0;
      position: relative;
      clear: both;
      background-color: #ffeecc;
      border: 1px solid black
  }
  .postulate  {
      padding: 0.5em;
      margin: 1em 0;
      position: relative;
      clear: both;
      background-color: #cceeff;
      border: 1px solid black
  }

    table { border-collapse:collapse; }
    table, td, th { border:1px solid black; }
    caption { font-weight: bold; text-align: left ; }
    code {color: #ff4500;}  /* Old W3C Style */
  </style>
</head>
<body>
<section id='abstract'>
  <p>  This document describes a precise semantics for
    [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]]
    and [[[RDF12-SCHEMA]]] [[RDF12-SCHEMA]].
    It defines a number of distinct entailment regimes and corresponding patterns of entailment.
    It is part of a suite of documents which comprise the full specification of RDF 1.2.</p>
</section>

<section id='sotd' class="updateable-rec">
  <p>This document is part of the RDF 1.2 document suite.
    This is a revision of the 2014 Semantics specification for RDF
    [[RDF11-MT]] and supersedes that document.
  </p>

  <section id="related" data-include="./common/related.html"></section>
</section>

   <section class='introductory'><h2 id="notes">Notes</h2>
     <p class='technote'>Notes in this style are technical asides on obscure or recondite matters.</p></section>
    <section>
      <h2 id="introduction">Introduction</h2>
      <p>
        This document defines a model-theoretic semantics for RDF graphs
        and the RDF and RDFS vocabularies, providing an exact formal specification
        of when truth is preserved by transformations of RDF or operations which derive
        RDF content from other RDF. </p>

    </section>

    <section id="conformance">
      <p>This specification, <em>RDF 1.2 Semantics</em>,
        is normative for RDF semantics and the validity of RDF inference processes.
        It is not normative for many aspects of RDF meaning which are not described
        or specified by this semantics,
        including social issues of how IRIs are assigned meanings in use
        and how the referents of IRIs are related to Web content expressed in other media
        such as natural language texts. </p>
    </section>

    <section id="extensions">
      <span id="semantic-extensions-and-entailment-regimes"><!-- obsolete identifier --></span>
      <h2>Semantic Extensions and Entailment Regimes</h2>
      <p>RDF is intended for use as a base notation for a variety of extended notations
        such as OWL [[?OWL2-OVERVIEW]] and RIF [[?RIF-OVERVIEW]],
        whose expressions can be encoded as RDF graphs
        which use a particular vocabulary with a specially defined meaning.
        Also, particular IRI vocabularies may be given meanings by other specifications or conventions.
        When such extra meanings are assumed,
        a given RDF graph may support more extensive entailments than are sanctioned by the basic RDF semantics.
        In general, the more assumptions that are made about the meanings of IRIs in an RDF graph,
        the more entailments follow from those assumptions. </p>

      <p>A particular such set of semantic assumptions is called a <dfn>semantic extension</dfn>.
        Each <a>semantic extension</a> defines an <dfn>entailment regime</dfn>
        (used here in the same sense as in the [[[?SPARQL12-ENTAILMENT]]] recommendation [[?SPARQL12-ENTAILMENT]] )
        of entailments which are valid under that extension.
        RDFS, described later in this document, is one such <a>semantic extension</a>.
        We will refer to entailment regimes by names such as <em> RDFS entailment</em>,
        <em>D-entailment</em>, etc. </p>

      <p><a>Semantic extension</a>s MAY impose special syntactic conditions or restrictions upon RDF graphs,
        such as requiring certain triples to be present,
        or prohibiting particular combinations of IRIs in triples,
        and MAY consider RDF graphs which do not conform to these conditions to be errors.
        For example, RDF statements of the form <br/><br/>
        <code>ex:a rdfs:subClassOf "Thing"^^xsd:string .</code><br/><br/>
        are prohibited in the OWL <a>semantic extension</a> based on description logics [[?OWL2-SYNTAX]].
        In such cases, basic RDF operations such as taking a subset of triples,
        or combining RDF graphs, may cause syntax errors in parsers which recognize the extension conditions.
        None of the <a>semantic extension</a>s normatively defined in this document
        impose such syntactic restrictions on RDF graphs.</p>

      <p>All entailment regimes MUST be <dfn class="no-export lint-ignore">monotonic</dfn> extensions
        of the simple entailment regime described in the document,
        in the sense that if A simply <a>entail</a>s B then A also entails B under any extended notion of entailment,
        provided that any syntactic conditions of the extension are also satisfied.
        Put another way, a <a>semantic extension</a> cannot "cancel" an entailment
        made by a weaker entailment regime,
        although it can treat the result as a syntax error.</p>
    </section>

  <section id="notation">
    <h2>Notation and Terminology</h2>

    <p>This document uses the following terminology for describing RDF graph syntax, all as defined in the companion RDF Concepts specification [[!RDF12-CONCEPTS]]:
      <dfn data-cite="RDF12-CONCEPTS#dfn-iri">IRI</dfn><span id="dfn-iri"></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-triple" data-lt="triple">RDF triple</dfn><span id="dfn-rdf-triple"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</dfn><span id="dfn-triple-term"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-graph" data-lt="graph">RDF graph</dfn><span id="dfn-rdf-graph"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-subject">subject</dfn><span id="dfn-subject"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-predicate">predicate</dfn><span id="dfn-predicate"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-object">object</dfn><span id="dfn-object"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-source">RDF source</dfn><span id="dfn-rdf-source"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-node">node</dfn><span id="dfn-node"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</dfn><span id="dfn-blank-node"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-literal">literal</dfn><span id="dfn-literal"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</dfn><span id="dfn-rdf-term"><!-- refer to RDF Concepts term --></span>,
      <dfn data-cite="RDF12-CONCEPTS#dfn-graph-isomorphism">isomorphic</dfn><span id="dfn-isomorphic"></span>, 
      <dfn data-cite="RDF12-CONCEPTS#dfn-appear" data-lt="appearing in">appears in</dfn><span id="dfn-appears-in"></span>, and
      <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-dataset" data-lt="dataset">RDF dataset</dfn><span id="dfn-rdf-dataset"><!-- refer to RDF Concepts term --></span>.
      All the definitions in this document apply unchanged to
      <dfn data-cite="RDF12-CONCEPTS#dfn-generalized-rdf-triple">generalized RDF triples</dfn>, 
      <dfn data-cite="RDF12-CONCEPTS#dfn-generalized-rdf-graph">generalized RDF graphs</dfn>, and
      <dfn data-cite="RDF12-CONCEPTS#dfn-generalized-rdf-dataset">generalized RDF datasets</dfn>.</p>

    <p>A <dfn>ground RDF graph</dfn> is an RDF graph in which no blank nodes appear.
      A <dfn>ground RDF term</dfn> is an RDF term in which no blank nodes appear.
      A <dfn>ground triple term</dfn> is a triple term term in which no blank nodes appear.
      A <dfn>ground RDF triple</dfn> is an RDF triple in which no blank nodes appear.</p>
    <!-- This may end up in RDF Concepts -->

    <p>An <dfn class="export">interpretation</dfn> is a mapping from <a>ground RDF terms</a> into a set,
      together with some constraints upon the set and the mapping.
      This document defines various notions of interpretation,
      each corresponding in a standard way to an entailment regime.
      These are identified by prefixes such as <em>simple interpretation</em>, etc.,
      and are defined in later sections.
      The unqualified term <em>interpretation</em> is usually used to refer to
      any compatible kind of interpretation in general,
      but if clear from the context might refer to a specific kind of interpretation.</p>

    <p>The word <dfn id="dfn-denote" data-cite="RDF12-CONCEPTS#dfn-denote" data-lt="denote" data-local-lt="denoted">denotes</dfn>
      is used here for the relationship between a <a>ground RDF term</a> 
      and what it refers to in a given interpretation,
      itself called the <dfn id="dfn-referent" data-cite="RDF12-CONCEPTS#dfn-referent">referent</dfn>.
      (The phrase <dfn class="no-export lint-ignore">refer to</dfn> is often used instead of denote and 
      <dfn class="no-export lint-ignore">denotation</dfn> instead of referent.)
      IRI meanings may also be determined by other constraints external to the RDF semantics;
      when we wish to refer to such an externally defined naming relationship,
      we will use the word <dfn class="no-export lint-ignore" data-local-lt="identified">identify</dfn> and its cognates.
      For example, the fact that the IRI <code>http://www.w3.org/2001/XMLSchema#decimal</code>
      is widely used as the <a>name</a> of a datatype described in the XML Schema document [[?XMLSCHEMA11-2]]
      might be described by saying that the IRI <em>identifies</em> that datatype.
      If an IRI identifies something it may or may not denote it in a given interpretation,
      depending on how the semantics is specified.
      For example, an IRI used as a graph name <a>identify</a>ing a named graph in an
      <a>RDF dataset</a> may denote something different from the graph it identifies.</p>

    <p>Throughout this document, the equality sign `=` indicates strict identity.
      The statement "A = B" means that there is one entity which both expressions "A" and "B" denote. 
      Angle brackets &lt; x, y &gt; are used to indicate an ordered pair of x and y.</p>

    <p>Throughout this document, <a>RDF graphs</a> and their components
      are written using the notational conventions of the Turtle syntax [[!RDF12-TURTLE]].
      The namespace prefixes <code>rdf:</code> <code>rdfs:</code> and <code>xsd:</code>
      are used as in the RDF Concepts specification [[!RDF12-CONCEPTS]],
      <a data-cite="RDF12-CONCEPTS#dfn-rdf-vocabulary">RDF vocabularies</a>.
      When the exact IRI does not matter, the prefix <code>ex:</code> is used.
      When stating general rules or conditions we use three-character variables such as
      aaa, xxx, sss  to indicate arbitrary IRIs, literals,
      or other components of RDF syntax.
      Some cases are illustrated by node-arc diagrams showing the graph structure directly.</p>

    <p>A <dfn>name</dfn> is any IRI or literal. A literal contains
      two <a>names</a>: itself and its internal type
      IRI. A <dfn>vocabulary</dfn> is a set of <a>names</a>.</p>

    <p>The <dfn>empty graph</dfn> is the empty set of triples.</p>

    <p>A <dfn>subgraph</dfn> of an <a>RDF graph</a> is a subset of the triples in the graph.
      A <a>triple</a> is identified with the singleton set containing it,
      so that each triple in a graph is considered to be a subgraph.
      A <dfn>proper subgraph</dfn> is a proper subset of the triples in the graph.</p>


  <p>
    For RDF terms t, x, and y, where either y is not a triple term or x does not appear in y, we define the <dfn>substitution mapping</dfn> t[x/y] inductively, as follows:
  </p>
  <ol>
    <li>If t = x, then t[x/y] = y.</li>
    <li>Otherwise, if t = (s, p, o), then t[x/y] = (s[x/y], p[x/y], o[x/y]).</li>
    <li>Otherwise, t[x/y] = t.</li>
  </ol>
  <p>
    For any triple (s, p, o), we define (s, p, o)[x/y] as (s[x/y], p[x/y], o[x/y]). For any graph G, we define G[x/y] as the result of applying [x/y] to each triple t in G.
  </p>


    <p>Suppose that M is a functional mapping from a set of blank
      nodes to some set of RDF terms. Any graph obtained
      from a graph G by replacing some or all of the blank nodes N <a>appearing in</a> G by M(N) is
      an <dfn>instance</dfn> of G. Any graph is an instance of itself,
      an instance of an instance of G is an instance of G,
      and if H is an instance of G then every triple in H is an instance of at least one triple
      in G.</p>
      
    <p>A <dfn>proper instance</dfn> of a graph
      is an <a>instance</a> in which a blank node has been mapped into something other than a blank node, or two blank
      nodes in the graph have been mapped into the same blank node. </p>

    <p>Two graphs are <a data-cite="RDF12-CONCEPTS#dfn-graph-isomorphism">isomorphic</a> when each maps into the other by a 1:1 mapping on blank nodes. Isomorphic graphs are mutual instances with an invertible instance
      mapping. As blank nodes have no particular identity beyond their location in a graph, we will often treat isomorphic graphs as identical.</p>

    <p>An RDF graph is <dfn>lean</dfn> if it has no instance which is
      a <a>proper subgraph</a> of itself. A <a>ground RDF graph</a> is lean. Non-lean graphs have internal redundancy
      and express the same content as their lean <a>subgraphs</a>. For example, the graph in Example 1 is not lean:</p>

    <pre class="example" title="Non-lean graph">
      ex:a ex:p _:x .
      _:y ex:p _:x .
    </pre>

    <p>In contrast, the graph in Example 2 <em>is</em> lean:</p>

    <pre class="example" title="Lean graph">
      ex:a ex:p _:x .
      _:x ex:p _:x .
    </pre>

    
  <section id="unions_merges">
    <h3>Shared blank nodes, unions, and merges</h3>

    <p>Graphs share <a>blank nodes</a> only if they are derived from graphs
      described by documents or other structures (such as an RDF dataset)
      that explicitly provide for the sharing of blank nodes between different RDF graphs.
      Simply downloading a web document does not mean that the blank nodes in a resulting RDF
      graph are the same as the blank nodes coming from other downloads of
      the same document or from the same <a>RDF source</a>.</p>

    <p> RDF applications which manipulate concrete syntaxes for RDF which use
      <a data-cite="RDF12-CONCEPTS#dfn-blank-node-identifier">blank node identifiers</a>
      should take care to keep track of the identity of the blank nodes they identify.
      Blank node identifiers often have a local scope,
      so when RDF from different sources is combined,
      identifiers may have to be changed in order to avoid accidental conflation
      of distinct blank nodes.</p>

    <p> For example, two documents may both use the blank node identifier "<code>_:x</code>"
      to identify a blank node, but unless these documents are in a shared identifier scope
      or are derived from a common source,
      the occurrences of "<code>_:x</code>" in one document
      will identify a different blank node than the occurrences of "<code>_:x</code>"
      in the other document.
      When graphs are formed by combining RDF from multiple sources,
      it may be necessary to <dfn class="no-export lint-ignore">standardize</dfn> apart the blank node identifiers
      by replacing them with other identifiers which do not occur in the other document(s).
      For example, the two graphs for the two texts below contain two nodes each, 
      for a total of four nodes:</p>

    <p><code>ex:a ex:p _:x . </code><br/><br/>
      <img src="RDF12SemanticsDiagrams/example1.svg" alt="Graph 1" /></p>

    <p><code>ex:b ex:q _:x . </code><br/><br/>
      <img src="RDF12SemanticsDiagrams/example2.svg" alt="Graph 2" ></p>

    <p>Their union would also contain four nodes:</p>

    <p><img src="RDF12SemanticsDiagrams/example4.svg" alt="Union Graph"></p>

    <p>However, if we simply concatenate these textual surface representations 
      to form a new document, as shown below:</p>

    <p><code>ex:a ex:p _:x .<br/>
    ex:b ex:q _:x .</code><br/></p>

    <p>The graph for this new document contains three nodes, because
      the two occurrences of the blank node identifier "<code>_:x</code>
      now occur in a common identifier scope, and thus identify the same blank node,
      as shown below:</p>

    <p><img src="RDF12SemanticsDiagrams/example3.svg" alt="Incorrect Union Graph"></p>

    <p>The four-node union
      of these two graphs is instead that shown below:</p>

    <p><code>ex:a ex:p _:x1 .<br/>
      ex:b ex:q _:x2 .</code></p>

    <p>Here the blank node identifiers have been <a data-lt="standardize">standardized apart</a>
      to avoid conflating the distinct blank nodes.
      (The particular blank node identifiers used have no significance; it matters only that they are distinct.)</p>

    <p>It is possible for two or more graphs to share a blank node,
      for example if they are <a>subgraphs</a> of a single larger graph or derived from a common source.
      In this case, the union of a set of graphs preserves the identity of blank nodes shared between the graphs.
      In general, the union of a set of RDF graphs accurately represents the same semantic content
      as the graphs themselves, whether or not they share blank nodes.</p>

    <p>A related operation, called <dfn class="no-export lint-ignore">merging</dfn>,
      takes the union after forcing any shared blank nodes,
      which occur in more than one graph, to be distinct in each graph.
      The resulting graph is called the <dfn data-lt="RDF graph merge">merge</dfn>.
      The merge of <a>subgraphs</a> of a graph may be larger than the original graph.
      For example, the result of merging the two singleton subgraphs of the three-node 
      graph shown below, is the four-node graph shown beneath:</p>

    <p><img src="RDF12SemanticsDiagrams/example3.svg" alt="Three-node Graph"></p>

    <p><img src="RDF12SemanticsDiagrams/example4.svg" alt="Four-node Graph"></p>

    <p>The union is always an instance of the merge. If graphs have no blank nodes in common,
      then their merge and union are identical. </p>

  </section>
</section>

<section id="simple">
  <h2>Simple Interpretations</h2>

  <p>This section defines the basic notions of simple interpretation and truth for RDF graphs.
    All <a>semantic extension</a>s of any vocabulary or higher-level notation encoded in RDF
    MUST conform to these minimal truth conditions.
    Other <a>semantic extension</a>s may extend and add to these,
    but they MUST NOT modify or negate them.
    For example, because simple interpretations are mappings which apply to IRIs,
    a <a>semantic extension</a> cannot interpret different occurrences of a single IRI differently.</p>

  <p>The entire semantics applies to <a>RDF graph</a>s, not to <a>RDF source</a>s.
    An <a>RDF source</a> has a semantic meaning only through the graph that is its value at a given time,
    or in a given state.
    Graphs cannot change their semantics with time.</p>


  <p>A <dfn data-lt="simply entail">simple interpretation</dfn> I is a structure consisting of:</p>

  <table>
    <caption>Definition of a simple interpretation.</caption>
    <tr>
          <td class="semantictable">1. A non-empty set IR, the resources of I, also called the domain or universe
              of I.
        <p>2. <span >A set IP, the properties of I.</span></p>
            <p>3. A mapping IEXT from IP into the powerset of IR x IR (the
              set of sets of pairs &lt; x, y &gt; with x and y in IR ), the extension mapping for properties in I.</p>
        <p>4. A mapping IS from IRIs into (IR union IP), the denotation mapping for symbols in I.</p>
        <p>5. A partial mapping IL from literals into IR, the denotation mapping for literals in I.</p>
        <p id="simple-injective-tests" data-tests="rdf-semantics/index.html#all-identical-triple-terms-are-the-same,
		       rdf-semantics/index.html#triple-term-not-asserted,
		       rdf-semantics/index.html#triple-terms-no-spurious">
	  6. An injective mapping IT from IR x IP x IR into IR, the extension mapping for triples in I. </p>
       </td>
    </tr>
  </table>

  <p class="technote">Simple interpretations are required to interpret all <a>names</a>,
    and are therefore infinite.
    RDF 1.1 can be interpreted using finite structures, as shown in 
	<a href="https://www.w3.org/TR/rdf11-mt/#finite-interpretations-informative">Appendix B</a> 
    of RDF 1.1 Semantic spec. </p>

  <p>IEXT(x), called the <dfn class="no-export lint-ignore">extension</dfn> of x,
    is a set of pairs which identify the arguments for which the property is true,
    that is, a binary relational extension.</p>

  <p>The distinction between IS and IL will become significant below when the semantics of datatypes are defined.
    IL is allowed to be partial because some literals may fail to have a referent. </p>

  <p class="technote">It is conventional to map a relation <a>name</a> to a relational extension directly.
    This however presumes that the vocabulary is segregated into relation <a>name</a>s and individual <a>name</a>s,
    and RDF makes no such assumption.
    Moreover, RDF allows an IRI to be used as a relation <a>name</a> applied to itself as an argument.
    Such self-application structures are used in RDFS, for example.
    The use of the IEXT mapping to distinguish the relation as an object from its relational extension
    accommodates both of these requirements.
    It also provides for a notion of RDFS 'class' which can be distinguished
    from its set-theoretic extension.
    A similar technique is used in the ISO/IEC Common Logic standard [[?ISO24707]].</p>

  <p>The referent of a ground RDF graph in a simple interpretation I is then given by the following rules,
    where the interpretation is also treated as a function from expressions (<a>names</a>, <a>triples</a> and <a>graphs</a>) to elements of the universe and truth values:</p>

  <table>
    <caption>Semantic conditions for ground graphs.</caption>
    <tbody>
      <tr>
        <td class="semantictable">if E is a literal then I(E) = IL(E)</td>
      </tr>

      <tr>
        <td class="semantictable">if E is an IRI, then I(E) = IS(E)</td>
      </tr>

      <tr>
        <td class="semantictable">if E is a ground triple term, then I(E) = IT(I(E.s), I(E.p), I(E.o)),<br/>
        where E.s, E.p, and E.o are the first, second, and third components of E, respectively</td>
      </tr>

      <tr>
        <td class="semantictable">if E is a ground triple `s p o.`,
          then I(E) = true if<br/>
          I(p) is in IP and the pair &lt;I(s),I(o)&gt;
          is in IEXT(I(p))<br/>
          otherwise I(E) = false.</td>
      </tr>

      <tr>
        <td class="semantictable">if E is a ground RDF graph then I(E) = false if I(E') =
          false for some triple E' in E, otherwise I(E) =true.</td>
      </tr>
    </tbody>
  </table>

  <p>If IL(E) is undefined for some literal E then E has no semantic value,
    so any triple containing it will be false,
    so any graph containing that triple will also be false.</p>

  <p>The final condition implies that the empty graph (the empty set of triples) is always true.</p>

  <p>The sets IP and IR may overlap, indeed IP can be a subset of IR.
    Because of the domain conditions on IEXT,
    the referent of the subject and object of any true triple will be in IR;
    so any IRI which occurs in a graph both as a predicate and as a subject or object
    will denote something in the intersection of IP and IR.</p>
  <p>We observe that no IRI, not even those in the <code>rdf:</code> namespace,
  has any special semantic condition associated with it in a simple interpretation.</p>

  <p><a>Semantic extensions</a> may impose further constraints upon interpretation mappings
    by requiring some IRIs to denote in particular ways.
    For example, D-interpretations, described below, require some IRIs,
    understood as <a>identify</a>ing and referring to datatypes, to have a fixed referent.</p>

  <section id="blank_nodes">
    <h3>Blank nodes</h3>

    <p>Blank nodes are treated as simply indicating the existence of a thing,
      without using an IRI to <a>identify</a> any particular thing.
      This is not the same as assuming that the blank node indicates an 'unknown' IRI.</p>

    <p>Suppose I is a simple interpretation and A is a mapping from a set of blank nodes
      to the universe IR of I.
      Define the mapping [I+A] as below:</p>
      <ul>
	<li> [I+A](x)=I(x) when x is a <a>name</a>. </li>
	<li> [I+A](x)=A(x) when x is a blank node. </li>
	<li> [I+A](x)=IT( [I+A](x.s), [I+A](x.p), [I+A](x.o) ) when x is a triple term, where x.s, x.p, and x.o are the first, second, and third components of x, respectively. </li>
	<li> [I+A](x)=true when x is a triple; x.s, x.p, and x.o are the first, second, and third components of x, respectively; [I+A](x.p) is in IP; and the pair &lt; [I+A](x.s), [I+A](x.o) &gt; is in IEXT([I+A](x.p)). </li>
	<li> [I+A](x)=false when x is a triple, otherwise. </li>
	<li> [I+A](x)=false when x is an RDF graph and [I+A](x')=false for some triple x' in x. </li>
	<li> [I+A](x)=true when x an RDF graph, otherwise. </li>
      </ul>
      <p>
      Extend this mapping to triples and RDF graphs using the rules given above for ground graphs.
      Then the semantic conditions for an RDF graph are:</p>

    <table>
      <caption>Semantic condition for blank nodes.</caption>
      <tbody>
        <tr>
          <td id="blank_nodes-semantic-condition-tests" class="semantictable" data-tests="rdf-semantics/index.html#bnodes-in-triple-term-object,
						rdf-semantics/index.html#bnodes-in-triple-term-subject,
						rdf-semantics/index.html#bnodes-in-triple-term-subject-and-object,
						rdf-semantics/index.html#bnodes-in-triple-term-fail,
						rdf-semantics/index.html#constrained-bnodes-in-triple-term-fail,
						rdf-semantics/index.html#constrained-bnodes-in-triple-term-object,
						rdf-semantics/index.html#constrained-bnodes-in-triple-term-subject,
						rdf-semantics/index.html#same-bnode-same-quoted-term,
						rdf-semantics/index.html#different-bnodes-same-triple-term">
	    If E is an RDF graph then I(E) = true if [I+A](E) =
          true for some mapping A from the set of blank nodes in E to IR, otherwise
          I(E)= false.</td>
        </tr>
      </tbody>
    </table>

    <p>Mappings from blank nodes to referents are not part of the definition of a simple interpretation,
      since the truth condition refers only to <em>some</em> such mapping.
      Blank nodes themselves differ from other nodes in not being assigned
      a referent by a simple interpretation, reflecting the intuition that
      they have no 'global' meaning.</p>

    <section id="shared_blank_nodes" class="informative">
      <h3>Shared blank nodes</h3>

      <p> The semantics for blank nodes are stated in terms of the truth of a graph. However, when two (or more) graphs share a blank node, their meaning is not fully captured by treating them in isolation. For example, consider the overlapping graphs</p>

      <p><img src="RDF12SemanticsDiagrams/example5.svg" alt="Overlapping Graphs" style="max-width: 100%"></p> 

      <p> and a simple interpretation I over the universe {Alice, Bob, Monica, Ruth} with:<br/>
        I(<code>ex:Alice</code>)=Alice, I(<code>ex:Bob</code>)=Bob, IEXT(I(<code>ex:hasChild</code>))={&lt;Alice,Monica&gt;,&lt;Bob,Ruth&gt; }<br/></p>

      <p>Each of the inner graphs is true under this interpretation,
        but the two of them together is not,
        because the three-node graph says that Alice and Bob have a child together.
        In order to capture the full meaning of graphs sharing a blank node,
        it is necessary to consider the union graph containing all the triples
        which contain the blank node.</p>

      <p class="technote"> RDF graphs can be viewed as conjunctions of simple atomic sentences in first-order logic,
        where blank nodes are free variables which are understood to be existential.
        Taking the union of two graphs is then analogous to syntactic conjunction in this syntax.
        RDF syntax has no explicit variable-binding quantifiers, so the truth conditions for any RDF graph
        treat the free variables in that graph as existentially quantified in that graph.
        Taking the union of graphs which share a blank node changes the implied quantifier scopes.</p>
    </section>
  </section>

  <section id="simpleentailment">
    <h2>Simple Entailment</h2>

    <p>Following standard terminology, we say that I (simply) <dfn>satisfies</dfn>
      E when I(E)=true, that E is (simply) <dfn>satisfiable</dfn>
      when a simple interpretation exists which <a>satisfies</a> it,
      otherwise (simply) <dfn>unsatisfiable</dfn>,
      and that a graph G simply <dfn  id="dfn-entail" data-cite="RDF12-CONCEPTS#dfn-entailment" data-lt="entail" data-local-lt="simple entailment|entailment">entails</dfn>
      a graph E when every interpretation which <a>satisfies</a> G also satisfies E.
      If two graphs E and F each entail the other then they are logically <dfn  id="dfn-equivalent" data-cite="RDF12-CONCEPTS#dfn-equivalence">equivalent</dfn>.
      If there are no (simple) interpretations that satisfy a graph then that graph is 
 <dfn id="dfn-inconsistent" data-cite="RDF12-CONCEPTS#dfn-inconsistent">inconsistent</dfn>.
    </p>

    <p>In later sections these notions will be adapted to other classes of interpretations,
      but throughout this section 'entailment' should be interpreted as meaning simple entailment.</p>

    <p class="technote">We do not define a notion of entailment between sets of graphs.
      To determine whether a set of graphs entails a graph,
      the graphs in the set must first be combined into one graph,
      either by taking the union or the merge of the graphs.
      Unions preserve the common meaning of shared blank nodes,
      while merging effectively ignores any sharing of blank nodes.
      Merging the set of graphs produces the same definition of entailment by a set
      that was defined in the 2004 RDF 1.0 specification.</p>

    <p>Any process which constructs a graph E from
      some other graph S is (simply) <dfn>valid</dfn> if S
      <a>simply entails</a> E in every case,
      otherwise <dfn class="no-export lint-ignore">invalid</dfn><span id="dfn-invalid.x"><!-- refer to RDF Concepts term --></span>.</p>

    <p>The fact that an inference is valid should not be understood as meaning
      that any RDF application is obliged or required to make the inference.
      Similarly, the logical invalidity of some RDF transformation or process
      does not mean that the process is incorrect or prohibited.
      Nothing in this specification requires or prohibits any particular operations on RDF graphs or sources.
      Entailment and validity are concerned solely with establishing the conditions
      on such operations which guarantee the preservation of truth.
      While logically invalid processes, which do not follow valid entailments,
      are not prohibited, users should be aware that they may be at risk of
      introducing falsehoods into true RDF data.
      Nevertheless, particular uses of logically invalid processes may be justified
      and appropriate for data processing under circumstances where truth can be
      ensured by other means.</p>

    <p>Entailment refers only to the truth of RDF graphs,
      not to their suitability for any other purpose.
      It is possible for an RDF graph to be fitted for a given purpose and yet validly entail
      another graph which is not appropriate for the same purpose.
      An example is the RDF test cases manifest [[?RDF-TESTCASES]] which is provided as an
      RDF document for user convenience.
      This document lists examples of correct entailments by describing their
      antecedents and conclusions.
      Considered as an RDF graph, the manifest <a>simply entails</a> a <a>subgraph</a>
      which omits the antecedents,
      and would therefore be incorrect if used as a test case manifest.
      This is not a violation of the RDF semantic rules, but it shows that the property of
      <em>"being a correct RDF test case manifest"</em>
      is not preserved under RDF entailment,
      and therefore cannot be described as an RDF <a>semantic extension</a>.
      Such entailment-risky uses of RDF should be restricted to cases,
      as here, where it is obvious to all parties what the intended special restrictions on entailment are,
      in contrast with the more normal case of using RDF for the open publication of data on the Web.</p>

  </section>

  <section id="simple_entailment_properties" class="informative">
    <h3>Properties of simple entailment and satisfiability</h3>

    <p>The properties described here apply only to simple entailment,
      not to extended notions of entailment introduced in later sections.
      Proofs are given in <a href="#proofs" class="sectionRef"></a>.</p>

    <p class="fact">Every graph is simply <a>satisfiable</a>.</p>

    <p id="ill-typed-tests" data-tests="
      ../rdf11/rdf-mt/index.html#datatypes-non-well-formed-literal-2,
      ../rdf11/rdf-mt/index.html#xmlsch-02-whitespace-facet-1,
      ../rdf11/rdf-mt/index.html#xmlsch-02-whitespace-facet-2,
      ../rdf11/rdf-mt/index.html#xmlsch-02-whitespace-facet-4">
      This does not always hold for extended notions of interpretation.
      For example, a graph containing an <a>ill-typed</a> literal is <a>D-unsatisfiable</a>.</p>

    <p>The following <dfn>interpolation</dfn> <strong>lemma</strong> </p>

    <p id="interpolation-lemma-tests" class="fact" data-tests="
      rdf-semantics/index.html#all-identical-triple-terms-are-the-same">
      G <a>simply entails</a> a graph E if and only if a <a>subgraph</a> of G is an instance of E.</p>

    <p>completely characterizes simple entailment in syntactic
      terms. To detect whether one RDF graph <a>simply entails</a> another, check that
      there is some instance of the entailed graph which is a subset of the first graph.</p>

  <p class="issue" data-number="102">The correctness of this claim may still be unclear.</p>

    <p class="technote">This is clearly decidable, but it is also difficult to determine in general,
      since one can encode the NP-hard <a>subgraph</a> problem (detecting whether
      one mathematical graph is a subgraph of another) as detecting simple entailment between RDF graphs.
      This construction (due to Jeremy Carroll) uses graphs all of whose nodes are blank nodes.
      The complexity of checking simple entailment is reduced by having fewer blank nodes in the conclusion E.
      When E is a <a>ground RDF graph</a>, it is simply a matter of checking the subset relationship on sets of triples.</p>

    <p><a>Interpolation</a> has a number of direct consequences, for example:</p>

    <p class="fact"> The <a>empty graph</a> is simply entailed by
      any graph, and does not simply entail any graph except itself.
    <!-- <a href="#emptygraphlemmaprf" class="termref">[Proof]</a> -->
    </p>
    <p class="fact"> A graph <a>simply entails</a> all its subgraphs.
    <!-- <a href="#subglemprf" class="termref">[Proof]</a> -->
    </p>
    <p class="fact"> A graph
      is simply entailed by any of its <a>instance</a>s.
    <!-- <a href="#instlemprf" class="termref"> [Proof]</a> -->
    </p>
    <p class="fact"> If
      E is a <a>lean</a> graph and E' is a <a>proper instance</a> of E, then E does
      not simply entail E'.
    </p>

    <p class="fact"> If S is a <a>subgraph</a> of S' and S <a>simply entails</a> E, then S' <a>simply entails</a> E.
    <!-- <a href="#monotonicitylemmaprf" class="termref"> [Proof]</a> -->
    </p>
    <p class="fact">
      If S entails a finite graph E, then some finite subset S' of S entails E.
    <!-- <a href="#compactlemmaprf" class="termref"> [Proof]</a> -->
    </p>
    <p>The property just above is called <em>compactness</em> - RDF is compact.
      As RDF graphs can be infinite, this is sometimes important.</p>

    <p class="fact"> If E contains an IRI which does not occur anywhere in S,
      then S does not simply entail E.</p>
      
    <p>The following semantic properties relate triple terms and triples asserted in a graph, and they introduce a general definition of satisfiability.</p>
    
    <p>We define the <dfn>set of propositions</dfn> in an interpretation as follows:</p>

	<p class="fact"> The set of propositions in an interpretation I is
	IPR(I)&nbsp;= {&nbsp;IT(x, y, z)&nbsp;&#65372;&nbsp;x&nbsp;is in IR,
	y&nbsp;is in IP, z&nbsp;is in IR&nbsp;}.</p>
	
	<p>The denotation of a triple is a proposition, whether it is used as a triple
	term or an asserted triple. Under <a href="#rdfs_interpretations">RDFS
	Interpretations</a> (see below), a proposition is in the extension of the
	class <code>rdfs:Proposition</code>.</p>

	<p>We define the <dfn>set of facts</dfn> in an interpretation as follows:</p>

	<p class="fact"> The set F of facts in an interpretation I is F(I) = {&nbsp;IT(x, y, z)&#65372;&lt;x, z&gt; is in IEXT(y)&nbsp;}. </p>
	
	<p>A fact in an interpretation is a proposition that holds in it, corresponding to a triple which is true in that interpretation.</p>

	<p>Given a blank node mapping, we define the <dfn>set of facts asserted by a graph</dfn> in an interpretation as follows:</p>

	<p class="fact">Given a blank node mapping&nbsp;A, the set of all facts
	asserted by a graph&nbsp;G in an interpretation&nbsp;I is FEXT(G, I,
	A)&nbsp;= {&nbsp;IT(&nbsp;[I+A](s), I(p), [I+A](o)&nbsp;)&#65372;
	`s p o.`&nbsp;is in G&nbsp;}.</p>
	
	<p>Given a blank node mapping and an interpretation, an asserted fact in a graph is the proposition corresponding to the denotation of a triple in the graph. These asserted facts may not necessarily be among the facts in the interpretation.
	Intuitively, this would only be the case if the interpretation satisfies the graph.
	</p>

	<p class="fact">An interpretation&nbsp;I (simply) <a>satisfies</a> a graph&nbsp;G
	if and only if there exists a blank node mapping&nbsp;A such that the facts
	asserted by the graph in the interpretation&nbsp;FEXT(G,I,A) are a subset of
	the facts of the interpretation&nbsp;F(I).</p>
	
  </section>
</section>

<section id="skolemization" class="informative">
  <h2>Skolemization</h2>

  <p><dfn class="no-export lint-ignore">Skolemization</dfn> is a transformation on RDF graphs
    which eliminates blank nodes by replacing them with "new" IRIs,
    which means IRIs which are coined for this purpose and are therefore guaranteed
    to not occur in any other RDF graph (at the time of creation).
    See <a data-cite="RDF12-CONCEPTS#section-skolemization">Replacing Blank Nodes with IRIs</a> in the RDF Concepts specification [[!RDF12-CONCEPTS]]
    for a fuller discussion.</p>

  <p>Suppose G is a graph containing blank nodes and sk is a skolemization mapping
    from the blank nodes in G to the skolem IRIs which are substituted for them,
    so that sk(G) is a skolemization of G.
    Then the semantic relationship between them can be summarized as follows.</p>

  <p class="fact">sk(G) <a>simply entails</a> G (since sk(G) is an instance of G.)</p>
  <p class="fact">G does not simply entail sk(G) (since sk(G) contains IRIs not in G.) </p>
  <p class="fact">For any graph H, if sk(G) <a>simply entails</a> H then there is a graph H' such that G entails H' and H=sk(H') . </p>
  <p class="fact">For any graph H which does not contain any of the "new" IRIs introduced into sk(G),
    sk(G) <a>simply entails</a> H if and only if G <a>simply entails</a> H.</p>

  <p>The second property means that a graph is not logically <a>equivalent</a> to its skolemization.
    Nevertheless, they are in a strong sense almost interchangeable in
    <a data-cite="RDF12-SEMANTICS#simple">RDF simple interpretations</a>,
    as shown by the next two properties. The third property means that even
    when conclusions which do contain the new vocabulary are drawn with
    <a data-cite="RDF12-SEMANTICS#simple">RDF simple entailment</a> from the
    skolemized graph, these will exactly mirror what could have been derived with
    <a data-cite="RDF12-SEMANTICS#simple">RDF simple entailment</a> from the original
    graph with the original blank nodes in place. The replacement of blank nodes
    with Skolem IRIs does not effectively alter what can be validly derived from the
    graph with <a data-cite="RDF12-SEMANTICS#simple">RDF simple entailment</a>,
    other than by giving new <a>names</a> to what were formerly anonymous
    entities. The fourth property, which is a consequence of the third, clearly
    shows that in some sense, a skolemization of G can "stand in for" G as far
    as <a data-cite="RDF12-SEMANTICS#simple">RDF simple entailments</a> are
    concerned. Using sk(G) instead of G will not affect any
    <a data-cite="RDF12-SEMANTICS#simple">RDF simple entailments</a> which do not
    involve the new skolem vocabulary.</p>

</section>

<section id="datatypes">
  <h2>Literals and datatypes</h2>

  <p>Datatypes are <a>identified</a> by IRIs.
    Interpretations will vary according to which IRIs are recognized as denoting datatypes.
    We describe this using a parameter D on simple interpretations,
    where D is the set of <dfn data-local-lt="recognized">recognize</dfn><em><strong>d</strong></em> datatype IRIs.</p>

  <p>The exact mechanism by which an IRI <a>identifies</a> a datatype is considered to be
    external to the semantics, but the semantics presumes that a recognized IRI <a>identifies</a>
    a unique datatype wherever it occurs.
    RDF processors which are not able to determine which datatype is identified by an IRI
    cannot <a>recognize</a> that IRI,
    and should treat any literals with that IRI as their datatype IRI as unknown <a>name</a>s.</p>

  <p>RDF literals and datatypes are fully described in the
    <a data-cite="RDF12-CONCEPTS#section-Datatypes">Datatypes</a> section of the RDF Concepts specification [[!RDF12-CONCEPTS]].
    In summary: with two exceptions, RDF literals combine a string and an IRI <a data-lt="identify">identifying</a> a datatype.
    The exceptions are <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string">language-tagged strings</a>,
    which have the type <code>rdf:langString</code>, and
    <a data-cite="RDF12-CONCEPTS#dfn-dir-lang-string">directional language-tagged strings</a>,
    which have the type <code>rdf:dirLangString</code>.
    <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string">Language-tagged strings</a>
    have two syntactic components: a string, and a language tag;
    <a data-cite="RDF12-CONCEPTS#dfn-dir-lang-string">directional language-tagged strings</a>
    have three syntactic components: a string, a language tag, and a base direction.
    A datatype is understood to define a mapping, called the
    <span id="dfn-lexical-to-value-mapping"></span>
    <dfn data-cite="RDF12-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</dfn>,
    from a lexical space (a set of <a data-cite="RDF12-CONCEPTS#dfn-rdf-string">strings</a>)
    to values.
    The function <dfn>L2V</dfn> maps datatypes to their lexical-to-value mapping.
    A literal with datatype d <a>denotes</a> the value obtained by applying this mapping
    to the <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>
    sss: L2V(d)(sss).
    If the literal string is not in the lexical space,
    so that the lexical-to-value mapping gives no value for the literal string,
    then the literal has no referent.
    The <dfn data-cite="RDF12-CONCEPTS#dfn-value-space">value space</dfn> of a
    datatype is the range of the <a>lexical-to-value mapping</a>.
    Every literal with that type either <a>denotes</a> a value in the value space of the type,
    or fails to denote at all.
    An <dfn data-cite="RDF12-CONCEPTS#dfn-ill-typed">ill-typed</dfn> literal
    is one whose datatype IRI is <a>recognized</a>, but whose
    <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>
    is not in the lexical space of the datatype identified by that IRI and
    thus is not in the domain of the <a>lexical-to-value mapping</a>
    of that datatype.</p>

  <p>RDF processors are not required to <a>recognize</a> any datatype IRIs other than
    <a data-cite="XMLSCHEMA11-2#string"><code>xsd:string</code></a>,
    <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string"><code>rdf:langString</code></a>, and
    <a data-cite="RDF12-CONCEPTS#dfn-dir-lang-string"><code>rdf:dirLangString</code></a>
    but when IRIs listed in the
    <a data-cite="RDF12-CONCEPTS#section-Datatypes">Datatypes</a> section of the RDF Concepts specification [[!RDF12-CONCEPTS]]
    <em>are</em> <a>recognized</a>, they MUST be interpreted as described there.
    RDF processors MAY recognize other datatype IRIs,
    but when other datatype IRIs are <a>recognized</a>,
    the mapping between the datatype IRI and the datatype it <a>denotes</a>
    MUST be specified unambiguously,
    and MUST be fixed during all RDF transformations or manipulations.
    In practice, this can be achieved by the IRI linking
    to an external specification of the datatype
    which describes both the components of the datatype itself
    and the fact that the IRI identifies the datatype,
    thereby fixing a value of the <a>datatype map</a> of this IRI.</p>

  <p>Literals with <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string"><code>rdf:langString</code></a>
    or <a data-cite="RDF12-CONCEPTS#dfn-dir-lang-string"><code>rdf:dirLangString</code></a>
    as their datatype IRI are given special treatment.
    The IRIs <code>rdf:langString</code> and <code>rdf:dirLangString</code>
    are classified as datatype IRIs and interpreted to denote a datatype,
    even though no <a>L2V</a> mapping is defined for them.
    The <a>value space</a> of <code>rdf:langString</code>
    is the set of all pairs of a string with a language tag.
    The <a>value space</a> of <code>rdf:dirLangString</code>
    is the set of all
    3-tuples of a string, a language tag, and a base direction.
    The semantics of literals with either of these as their datatype are given below.
    </p>

  <p>RDF allows any IRI to be used in a literal,
    even when it is not <a>recognized</a> as referring to a datatype.
    Literals with such an "unknown" datatype IRI,
    which is not in the set of <a>recognized</a> datatypes,
    SHOULD NOT be treated as errors, although RDF applications MAY issue a warning.
    Such literals SHOULD be treated like IRIs and assumed to denote some thing in the universe IR.
    RDF processors which do not <a>recognize</a> a datatype IRI will not be able
    to detect some entailments which are visible to one which does.
    For example, the fact that</p>

  <p><code>ex:a ex:p "20.0000"^^xsd:decimal .</code></p>
  <p>entails</p>
  <p><code>ex:a ex:p "20.0"^^xsd:decimal .</code></p>

  <p>will not be visible to a processor which does not <a>recognize</a> the datatype IRI <code>xsd:decimal</code>.</p>

  <section id="D_interpretations">
    <h2>D-interpretations</h2>

    <p>Let D be a set of IRIs <a>identify</a>ing datatypes.
      A  <strong>(simple)</strong> <dfn>D-interpretation</dfn> is a <a>simple interpretation</a>
      which satisfies the following conditions:</p>

    <table>
      <caption>Semantic conditions for literals.</caption>
      <tbody>
        <tr><td id="d-int-langString-tests" class="semantictable" data-tests="
          ../rdf11/rdf-mt/index.html#tex-01-language-tag-case-1,
          ../rdf11/rdf-mt/index.html#tex-01-language-tag-case-2,
          rdf-semantics/index.html#opaque-language-string,
          rdf-semantics/index.html#opaque-language-string-control">
          If <code>rdf:langString</code> is in D,
          then for every language-tagged string E with lexical form sss and language tag ttt,
          IL(E)= &lt; sss, ttt' &gt;, where ttt' is ttt converted to lower case using US-ASCII rules</td></tr>
        <tr><td class="semantictable">If <code>rdf:dirLangString</code> is in D,
          then for every directional language-tagged string E with lexical form sss,
            language tag ttt, and base direction bbb,
          IL(E)= &lt; sss, ttt', bbb &gt;, where ttt' is ttt converted to lower case using US-ASCII rules</td></tr>
        <tr><td id="D_interpretations-literal-tests" class="semantictable" data-tests="rdf-semantics/index.html#malformed-literal,
						  rdf-semantics/index.html#malformed-literal-accepted,
						  rdf-semantics/index.html#malformed-literal-bnode,
						  rdf-semantics/index.html#opaque-literal,
						  rdf-semantics/index.html#opaque-literal-control,
						  rdf-semantics/index.html#float-zero,
						  rdf-semantics/index.html#float-round-different,
						  rdf-semantics/index.html#float-round-same,
						  rdf-semantics/index.html#float-infinity,
						  rdf-semantics/index.html#double-zero,
						  rdf-semantics/index.html#double-round-different,
						  rdf-semantics/index.html#double-round-same,
						  rdf-semantics/index.html#double-infinity">
	    For every other IRI aaa in D,
          I(aaa) is the datatype identified by aaa, and for every literal
          "sss"^^aaa, IL("sss"^^aaa) = L2V(I(aaa))(sss)</td></tr>
     </tbody>
   </table>

   <p>If the literal is <a>ill-typed</a> then the L2V(I(aaa)) mapping has no value,
     and so the literal cannot denote anything.
     In this case, any triple containing the literal must be false.
     Thus, any triple, and hence any graph, containing an <a>ill-typed</a> literal will be
     <a>D-unsatisfiable</a>, i.e. false in every D-interpretation.
     This applies only to literals typed with recognized datatype IRIs in D;
     literals with an unrecognized type IRI are not <a>ill-typed</a> and cannot give rise to
     a <a>D-unsatisfiable</a> graph.</p>

    <p>The special datatypes
      <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string"><code>rdf:langString</code></a> and
      <a data-cite="RDF12-CONCEPTS#dfn-dir-lang-string"><code>rdf:dirLangString</code></a>
      have no <a>ill-typed</a> literals.
      Any syntactically legal literal with one of these types will denote a value in every
      D-interpretation where D includes <code>rdf:langString</code> or <code>rdf:dirLangString</code>.
      The only ill-typed literals of type <a data-cite="XMLSCHEMA11-2#string"><code>xsd:string</code></a>
      are those containing a Unicode code point which does not match
      the <a data-cite="XML11#NT-Char"><em>Char</em> production</a> in [[[?XML11]]] [[?XML11]].
      Such strings cannot be written in an XML-compatible surface syntax.</p>

  </section>

  <section id="D_entailment">
    <h3>Datatype entailment</h3>

    <p>A graph is (simply) <dfn class="no-export lint-ignore">D-satisfiable</dfn> or
      <dfn class="no-export lint-ignore">satisfiable recognizing D</dfn> when it has the value true
      in some D-interpretation, and a graph S (simply) <dfn>D-entails</dfn> or
      <dfn>entails recognizing D</dfn> a graph G when every D-interpretation which
      <a>satisfies</a> S also D-satisfies G.</p>

    <p> Unlike the case with <a>simple interpretation</a>s,
      it is possible for a graph to have no satisfying D-interpretations
       i.e. to be <dfn class="no-export lint-ignore" data-lt="D-unsatisfiability">D-unsatisfiable</dfn>.
       RDF processors MAY treat an unsatisfiable graph as signaling an error condition,
       but this is not required.</p>

    <p> A <a>D-unsatisfiable</a> graph <a>D-entails</a> any graph.</p>

    <p class="technote">The fact that an <a>unsatisfiable</a> statement entails any other statement
      has been known since antiquity.
      It is called the principle of <em>ex falso quodlibet</em>.
      It should not be interpreted to mean that it is necessary,
      or even permissible, to actually draw any conclusion from an <a>unsatisfiable</a> graph.</p>

    <p>In all of this language, 'D' is being used as a parameter to represent some set of datatype IRIs,
      and different D sets will yield different notions of satisfiability and entailment.
      The more datatypes are <a>recognized</a>, the stronger is the entailment,
      so that if D &subset; E and S E-entails G then S must <a>D-entail</a> G.
      Simple entailment is {&nbsp;}-entailment, i.e. D-entailment when D is the empty set,
      so if S <a>D-entails</a> G  then S <a>simply entails</a> G. </p>

    <section id="datatype_entailment_patterns" class="informative">
      <h4>Patterns of datatype entailment</h4>

      <p>Unlike <a>simple entailment</a>, it is not possible to give a single syntactic criterion
        to detect all D-entailments,
        which can hold because of particular properties of the lexical-to-value mappings
        of the <a>recognized</a> datatypes.
        For example, if D contains <code>xsd:decimal</code> then</p>

      <p><code>ex:a ex:p "25.0"^^xsd:decimal .</code></p>

      <p>D-entails</p>

      <p><code>ex:a ex:p "25"^^xsd:decimal .</code></p>

      <p>In general, any triple containing a literal with a <a>recognized</a>
        datatype IRI <a>D-entails</a> another literal when the lexical strings of
        the literals map to the same value under the lexical-to-value map of the datatype.
        If two different datatypes in D map lexical strings to a common value,
        then a triple containing a literal typed with one datatype may <a>D-entail</a>
        another triple containing a literal typed with a different datatype.
        For example, <code>"25"^^xsd:integer</code> and <code>"25.0"^^xsd:decimal</code>
        have the same value, so the above also <a>D-entails</a></p>

      <p><code>ex:a ex:p "25"^^xsd:integer .</code></p>

      <p>when D also contains <code>xsd:integer</code>.</p>

      <p>(There is a W3C Note [[SWBP-XSCH-DATATYPES]] containing a long
        <a data-cite="SWBP-XSCH-DATATYPES#sec-values">discussion</a> of literal values.)</p>

      <p><a>Ill-typed</a> literals are the only way in which a graph can be simply <a>D-unsatisfiable</a>,
        but datatypes can give rise to a variety of other <a>unsatisfiable</a> graphs
        when combined with the RDFS vocabulary, defined later.</p>
    </section>

  </section>
</section>

<section id="rdf_d_interpretations">
  <h2>RDF Interpretations</h2>

  <p>RDF interpretations impose extra semantic conditions on <code>xsd:string</code>
    and part of the infinite set of IRIs with the namespace prefix <code>rdf:</code> .

  <table>
    <tbody>
      <tr>
        <td ><dfn>RDF vocabulary</dfn></td>
      </tr>

      <tr>
        <td ><code>rdf:type rdf:reifies rdf:subject rdf:predicate rdf:object
          rdf:first rdf:rest rdf:value rdf:nil
          rdf:List rdf:langString rdf:dirLangString rdf:Property rdf:_1 rdf:_2
           ...</code></td>
      </tr>
    </tbody>
  </table>

  <p>An <dfn>RDF interpretation</dfn> <strong>recognizing D</strong> is a <a>D-interpretation</a> I
    where D includes <code>rdf:langString</code>, <code>rdf:dirLangString</code>, and <code>xsd:string</code>, and which satisfies:</p>

  <table>
    <caption>RDF semantic conditions.</caption>
    <tbody>
      <tr>
        <td class="semantictable" id="rdfsemcond1">x is
          in IP if and only if &lt;x, I(<code>rdf:Property</code>)&gt; is in IEXT(I(<code>rdf:type</code>))</td>
      </tr>
      <tr>
        <td class="semantictable" id="rdfsemcond3">For every IRI aaa in D, &lt; x,
          I(aaa) &gt; is in IEXT(I(<code>rdf:type</code>)) if and only if x is in the <a>value space</a> of I(aaa)</td></tr>
    </tbody>
  </table>

  <p>and <a>satisfies</a> every triple in the following infinite set:</p>

  <table>
   <caption>RDF axioms.</caption>
    <tr>
      <td class="ruletable" id="RDF_axiomatic_triples"><code>rdf:type rdf:type rdf:Property .<br/>
        rdf:subject rdf:type rdf:Property .<br/>
        rdf:predicate rdf:type rdf:Property .<br/>
        rdf:object rdf:type rdf:Property .<br/>
        rdf:reifies rdf:type rdf:Property .<br/>
        rdf:first rdf:type rdf:Property .<br/>
        rdf:rest rdf:type rdf:Property .<br/>
        rdf:value rdf:type rdf:Property .<br/>
        rdf:nil rdf:type rdf:List .<br/>
        rdf:_1 rdf:type rdf:Property .<br/>
        rdf:_2 rdf:type rdf:Property .<br/>
        ...<br/></code>
        </td>
    </tr>
  </table>

  <p>RDF intrepretations impose no particular normative semantics on the rest of the RDF vocabulary.
</p>

  <p>The datatype IRIs 
    <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string"><code>rdf:langString</code></a>,
    <a data-cite="RDF12-CONCEPTS#dfn-dir-lang-string"><code>rdf:dirLangString</code></a>,
    and <a data-cite="XMLSCHEMA11-2#string"><code>xsd:string</code></a>
    MUST be <a>recognized</a> by all RDF interpretations.</p>

<p id="rdf_d_interpretations-failure-tests" data-tests="rdf-semantics/index.html#json-array-unordered,
		 rdf-semantics/index.html#json-object-ordered,
		 rdf-semantics/index.html#json-zero,
		 rdf-semantics/index.html#json-zero-array,
		 rdf-semantics/index.html#json-round-different,
		 rdf-semantics/index.html#json-round-same,
		 rdf-semantics/index.html#json-infinity">
    Three other datatypes &mdash; <a data-cite="RDF12-CONCEPTS#section-XMLLiteral"><code>rdf:XMLLiteral</code></a>,
    <a data-cite="RDF12-CONCEPTS#section-html"><code>rdf:HTML</code></a>, and
    <a data-cite="RDF12-CONCEPTS#section-json"><code>rdf:JSON</code></a> &mdash;
    are defined in the RDF Concepts specification [[!RDF12-CONCEPTS]].
    RDF-D interpretations MAY fail to <a>recognize</a> these datatypes.</p>

  <section id="rdf_entail">
    <h3>RDF entailment</h3>

    <p>S <dfn>RDF entail</dfn><strong>s</strong> E <strong>recognizing D</strong>
      when every <a>RDF interpretation</a> recognizing D which <a>satisfies</a>
      S also satisfies E. When D is {<code>rdf:langString</code>,
      <code>rdf:dirLangString</code>, <code>xsd:string</code>}
      then we simply say S <strong>RDF entails</strong> E.
      E is <dfn>RDF unsatisfiable</dfn><strong> (recognizing D)</strong>
      when it has no satisfying <a>RDF interpretation</a> (recognizing D).</p>

    <p>The properties of <a>simple entailment</a> described earlier do not all apply to <a>RDF entail</a>ment.
      For example, all the RDF axioms are true in every <a>RDF interpretation</a>,
      and so are <a>RDF entail</a>ed by the empty graph, contradicting <a>interpolation</a> for RDF entailment. </p>

    <section id="rdf_entailment_patterns" class="informative">
      <h4>Patterns of RDF entailment</h4>

      <p>The last semantic condition in the above table gives the following entailment pattern for <a>recognized</a> datatype IRIs:</p>

      <table>
        <caption>RDF entailment pattern.</caption>
        <tbody>
          <tr>
            <th > </th>
            <th ><strong>if S contains</strong></th>
            <th ><strong>then S RDF entails, recognizing D</strong></th>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfD1</dfn></td>
            <td class="othertable">Any triple ttt such that <code>"</code>sss<code>"^^</code>ddd <a>appears in</a> ttt <br/>
                for ddd in D</td>
            <td class="othertable">ttt [<code>"</code>sss<code>"^^</code>ddd/_:nnn] <br/>
      _:nnn <code>rdf:type</code> ddd <code>.</code></td>
          </tr>
        </tbody>
      </table>

      <p>Note, this is valid even when the literal is <a>ill-typed</a>, since an unsatisfiable graph entails any triple.</p>

      <p>For example,</p>

      <p><code>ex:a ex:p "123"^^xsd:integer .</code></p>

      <p>RDF entails recognizing {<code>xsd:integer</code>}</p>

      <p><code>ex:a ex:p _:x . <br/>
       _:x rdf:type xsd:integer . </code></p>

      <p>The last semantic condition above also justifies the following entailment pattern:</p>

      <table>
        <tbody>
          <tr>
            <th> </th>
            <th><strong>any S</strong></th>
            <th><strong>then S RDF entails, recognizing D</strong></th>
          </tr>
          <tr>
            <td class="othertable"><dfn>rdfD1a</dfn></td>
            <td class="othertable">for ddd in D with non-empty value space</td>
            <td class="othertable">_:nnn <code>rdf:type</code> ddd <code>.</code></td>
          </tr>
        </tbody>
      </table>



      <p>In addition, the first RDF semantic condition justifies the following entailment pattern:</p>

<!-- 
      <table>
        <tbody>
          <tr>
            <th></th>
            <th><strong>if S contains</strong></th>
            <th><strong>then S RDF entails, recognizing D</strong></th>
          </tr>

          <tr>
             <td class="othertable"><dfn>rdfD2</dfn></td>
             <td class="othertable">xxx aaa yyy <code>.</code></td>
             <td class="othertable">aaa <code>rdf:type rdf:Property .</code> </td>
          </tr>
        </tbody>
      </table>
 -->
 
       <table>
        <tbody>
          <tr>
            <th></th>
            <th><strong>if the triple <a>appears in</a> S</strong></th>
            <th><strong>then S RDF entails, recognizing D</strong></th>
          </tr>

          <tr>
             <td class="othertable"><dfn>rdfD2</dfn></td>
             <td class="othertable">xxx aaa yyy <code>.</code></td>
             <td class="othertable">aaa <code>rdf:type rdf:Property .</code> </td>
          </tr>
        </tbody>
      </table>

      <p>So that the above example also RDF entails</p><p><code>ex:p rdf:type rdf:Property .</code></p>
      <p> recognizing {<code>xsd:integer</code>}.</p>

      <p>Some datatypes support idiosyncratic entailment patterns which do not hold for other datatypes. For example,</p>

      <p><code> ex:a ex:p "true"^^xsd:boolean .<br/>
        ex:a ex:p "false"^^xsd:boolean .<br/>
        ex:v rdf:type xsd:boolean .</code></p>

      <p>together RDF entail</p>

      <p><code>ex:a ex:p ex:v .</code></p>

      <p>recognizing {<code>xsd:boolean</code>}.</p>

      <p>In addition, the semantic conditions on <a>value spaces</a> may produce other <a>unsatisfiable</a> graphs.
        For example, when D contains <code>xsd:integer</code> and <code>xsd:boolean</code>,
        then the following is <a>RDF unsatisfiable</a> recognizing D:</p>

      <p><code>_:x rdf:type xsd:boolean .<br/>
      _:x rdf:type xsd:integer . </code></p>

    </section>
  </section>
</section>

<section id="rdfs_interpretations">
  <h2>RDFS Interpretations</h2>

  <p>RDF Schema [[RDF12-SCHEMA]]
    extends RDF to a larger vocabulary
    with more complex semantic constraints:</p>

  <table>
    <tbody>
      <tr>
        <td ><dfn>RDFS vocabulary</dfn></td>
      </tr>

      <tr>
        <td ><code>rdfs:domain rdfs:range rdfs:Resource rdfs:Literal
        rdfs:Datatype rdfs:Class rdfs:subClassOf rdfs:subPropertyOf
        rdfs:Proposition 
        rdfs:member rdfs:Container rdfs:ContainerMembershipProperty
        rdfs:comment rdfs:seeAlso rdfs:isDefinedBy
        rdfs:label</code></td>
      </tr>
    </tbody>
  </table>

  <p>(<code>rdfs:comment</code>,<code> rdfs:seeAlso</code>, <code>rdfs:isDefinedBy</code>
    and <code>rdfs:label</code> are included here because some constraints which
    apply to their use can be stated using <code>rdfs:domain</code>,<code> rdfs:range</code>
    and <code>rdfs:subPropertyOf</code>. Other than this, the formal semantics does
    not constrain their meanings.)</p>

  <p>It is convenient to state the RDFS semantics
    in terms of a new semantic construct, a <dfn>class</dfn>, i.e. a resource which represents
    a set of things in the universe which all have that class as a value of their
    <code>rdf:type</code> property. <a>Class</a>es are defined to be things of type <code>rdfs:Class</code>,
    and the set of all classes in an interpretation will be called IC.
    The semantic conditions are stated in terms of a mapping ICEXT (for the <em>C</em>lass
    <em>Ext</em>ension in I) from IC to the set of subsets of IR.</p><p> A class may have an
    empty class extension. Two different classes can have the same class extension.
    The class extension of <code>rdfs:Class</code> contains the class <code>rdfs:Class</code>.</p>
    
  <p>RDFS also introduces the class <code>rdfs:Proposition</code>,
    whose extension is exactly the <a>set of propositions</a> as defined
    in [[[#simple_entailment_properties]]].
    This class is also declared as `rdfs:range` of the `rdf:reifies` property.
    In other words, the object of a <a data-cite="RDF12-CONCEPTS#dfn-reifying-triple">reifying triple</a>
    always denotes a <a data-cite="RDF12-CONCEPTS#dfn-proposition">proposition</a>. 

  <p> An <dfn>RDFS interpretation</dfn> (<strong>recognizing D</strong>) is an
  <a>RDF interpretation</a> (recognizing D)&nbsp;I which <a>satisfies</a> the
  semantic conditions in the following table, and all the triples in the
  subsequent table of RDFS axiomatic triples.</p>

  <table id="rdfs_semantic_conditions">
    <caption>RDFS semantic conditions.</caption>
    <tr>
      <td class="semantictable" id="rdfssemcond1"> <p>ICEXT(y) is defined to be { x : &lt; x,y &gt; is in IEXT(I(<code>rdf:type</code>)) }</p>
        <p>IC is defined to be ICEXT(I(<code>rdfs:Class</code>))</p>
        <p>LV is defined to be ICEXT(I(<code>rdfs:Literal</code>))</p>
        <p>ICEXT(I(<code>rdfs:Resource</code>)) = IR</p>
        <p>ICEXT(I(<code>rdf:langString</code>)) is the set {I(E) : E a language-tagged string }</p>
        <p>ICEXT(I(<code>rdf:dirLangString</code>)) is the set {I(E) : E a directional language-tagged string }</p>
        <p>for every other IRI aaa in D, ICEXT(I(aaa)) is the <a>value space</a> of I(aaa)</p>
        <p>for every IRI aaa in D, I(aaa) is in ICEXT(I(<code>rdfs:Datatype</code>))</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond2"> <p>If
        &lt; x,y &gt; is in IEXT(I(<code>rdfs:domain</code>)) and &lt; u,v &gt; is
        in IEXT(x) then u is in ICEXT(y)</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond3"> <p>If
        &lt; x,y &gt; is in IEXT(I(<code>rdfs:range</code>)) and &lt; u,v &gt; is
        in IEXT(x) then v is in ICEXT(y)</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond4"><p>IEXT(I(<code>rdfs:subPropertyOf</code>))
        is transitive and reflexive on IP</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond5"> <p>If
        &lt;x,y&gt; is in IEXT(I(<code>rdfs:subPropertyOf</code>)) then x and
        y are in IP and IEXT(x) is a subset of IEXT(y)</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond6"><p>If
        x is in IC then &lt; x, I(<code>rdfs:Resource</code>) &gt; is in IEXT(I(<code>rdfs:subClassOf</code>))</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond8"><p>IEXT(I(<code>rdfs:subClassOf</code>))
        is transitive and reflexive on IC</p></td>
    </tr>

     <tr>
       <td class="semantictable" id="rdfssemcond7"> <p>If
          &lt; x,y &gt; is in IEXT(I(<code>rdfs:subClassOf</code>)) then x and y are
          in IC and ICEXT(x) is a subset of ICEXT(y)</p></td>
    </tr>

    <tr>
      <td class="semantictable" id="rdfssemcond9"><p>If
        x is in ICEXT(I(<code>rdfs:ContainerMembershipProperty</code>)) then:<br/>
        &lt; x, I(<code>rdfs:member</code>) &gt; is in IEXT(I(<code>rdfs:subPropertyOf</code>))<br/></td>
    </tr>
    <tr>

    <td class="semantictable" id="rdfssemcond10"><p>If
      x is in ICEXT(I(<code>rdfs:Datatype</code>)) then <span >&lt; x,
      I(<code>rdfs:Literal</code>) &gt; is in IEXT(I(<code>rdfs:subClassOf</code>))</span></p></td>
    </tr>
    <tr>
    <td class="semantictable" id="rdfssemcond11" data-tests="rdf-semantics/index.html#triple-terms-propositions"><p>If
      exist x,y,z such that IT(x,z,y)=r
      <br/> 
      then &lt; r,I(<code>rdfs:Proposition</code>)&gt; 
        is in IEXT(I(<code>rdf:type</code>))</p></td>
    </tr>
  </table>

  <table id="RDFS_axiomatic_triples" data-tests="rdf-semantics/index.html#reifies-range">
    <caption>RDFS axiomatic triples.</caption>
    <tr>
      <td class="ruletable"> <code>rdf:type rdfs:domain rdfs:Resource .<br/>
        rdf:reifies rdfs:domain rdfs:Resource .<br/>
        rdfs:domain rdfs:domain rdf:Property .<br/>
        rdfs:range rdfs:domain rdf:Property .<br/>
        rdfs:subPropertyOf rdfs:domain rdf:Property .<br/>
        rdfs:subClassOf rdfs:domain rdfs:Class .<br/>
        rdf:subject rdfs:domain rdf:Statement .<br/>
        rdf:predicate rdfs:domain rdf:Statement .<br/>
        rdf:object rdfs:domain rdf:Statement .<br/>
        rdfs:member rdfs:domain rdfs:Resource . <br/>
        rdf:first rdfs:domain rdf:List .<br/>
        rdf:rest rdfs:domain rdf:List .<br/>
        rdfs:seeAlso rdfs:domain rdfs:Resource .<br/>
        rdfs:isDefinedBy rdfs:domain rdfs:Resource .<br/>
        rdfs:comment rdfs:domain rdfs:Resource .<br/>
        rdfs:label rdfs:domain rdfs:Resource .<br/>
        rdf:value rdfs:domain rdfs:Resource .<br/>
        <br/>
        rdf:type rdfs:range rdfs:Class .<br/>
        rdf:reifies rdfs:range rdfs:Proposition .<br/>
        rdfs:domain rdfs:range rdfs:Class .<br/>
        rdfs:range rdfs:range rdfs:Class .<br/>
        rdfs:subPropertyOf rdfs:range rdf:Property .<br/>
        rdfs:subClassOf rdfs:range rdfs:Class .<br/>
        rdf:subject rdfs:range rdfs:Resource .<br/>
        rdf:predicate rdfs:range rdfs:Resource .<br/>
        rdf:object rdfs:range rdfs:Resource .<br/>
        rdfs:member rdfs:range rdfs:Resource .<br/>
        rdf:first rdfs:range rdfs:Resource .<br/>
        rdf:rest rdfs:range rdf:List .<br/>
        rdfs:seeAlso rdfs:range rdfs:Resource .<br/>
        rdfs:isDefinedBy rdfs:range rdfs:Resource .<br/>
        rdfs:comment rdfs:range rdfs:Literal .<br/>
        rdfs:label rdfs:range rdfs:Literal .<br/>
        rdf:value rdfs:range rdfs:Resource .<br/>
        <br/>
        rdf:Alt rdfs:subClassOf rdfs:Container .<br/>
        rdf:Bag rdfs:subClassOf rdfs:Container .<br/>
        rdf:Seq rdfs:subClassOf rdfs:Container .<br/>
        rdfs:ContainerMembershipProperty rdfs:subClassOf rdf:Property .<br/>
        <br/>
        rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso .<br/>
        <br/>
        rdfs:Datatype rdfs:subClassOf rdfs:Class .<br/>
        <br/>
        rdf:_1 rdf:type rdfs:ContainerMembershipProperty .<br/>
        <span >rdf:_1 rdfs:domain rdfs:Resource .<br/>
        rdf:_1 rdfs:range rdfs:Resource .</span> <br/>
        rdf:_2 rdf:type rdfs:ContainerMembershipProperty .<br/>
        rdf:_2 rdfs:domain rdfs:Resource .<br/>
        rdf:_2 rdfs:range rdfs:Resource . <br/>
        </code>... <br/> 
        </td>
    </tr>
  </table>

  <p>Since I is an <a>RDF interpretation</a>, the first condition implies that IP
    = ICEXT(I(<code>rdf:Property</code>)).</p>

  <p>The semantic conditions on <a>RDF interpretation</a>s,
    together with the RDFS conditions on ICEXT, mean that every <a>recognized</a> datatype
    can be treated as a class whose extension is the <a>value space</a> of the datatype,
    and every literal with that datatype either fails to denote, or <a>denotes</a> a value in that class.</p>

  <p>When using RDFS semantics, the referents of all <a>recognized</a> datatype IRIs can be considered
    to be in the <a>class</a> <code>rdfs:Datatype</code>.</p>

  <p>The axioms and conditions listed above have some redundancy. For example, all but one
    of the RDF axiomatic triples can be derived from the RDFS axiomatic triples
    and the semantic conditions on ICEXT,<code> rdfs:domain</code> and <code>rdfs:range</code>. </p>

  <p>Other triples which must be true in all RDFS interpretations
    include the following. This is not a complete set.</p>

  <table>
    <caption>Some rdfs-valid triples.</caption>
    <tr>
      <td class="ruletable"><code>rdfs:Resource rdf:type rdfs:Class .<br/>
        rdfs:Class rdf:type rdfs:Class .<br/>
        rdfs:Literal rdf:type rdfs:Class .<br/>
        rdf:XMLLiteral rdf:type rdfs:Class .<br/>
  rdf:HTML rdf:type rdfs:Class .<br/>
        rdfs:Datatype rdf:type rdfs:Class .<br/>
        rdf:Seq rdf:type rdfs:Class .<br/>
        rdf:Bag rdf:type rdfs:Class .<br/>
        rdf:Alt rdf:type rdfs:Class .<br/>
        rdfs:Container rdf:type rdfs:Class .<br/>
        rdf:List rdf:type rdfs:Class .<br/>
        rdfs:ContainerMembershipProperty rdf:type rdfs:Class .<br/>
        rdf:Property rdf:type rdfs:Class .<br/>
        rdf:Statement rdf:type rdfs:Class .<br/>
        <br/>
        rdfs:domain rdf:type rdf:Property .<br/>
        rdfs:range rdf:type rdf:Property .<br/>
        rdfs:subPropertyOf rdf:type rdf:Property .<br/>
        rdfs:subClassOf rdf:type rdf:Property .<br/>
        rdfs:member rdf:type rdf:Property .<br/>
        rdfs:seeAlso rdf:type rdf:Property .<br/>
        rdfs:isDefinedBy rdf:type rdf:Property .<br/>
        rdfs:comment rdf:type rdf:Property .<br/>
        rdfs:label rdf:type rdf:Property .<br/>
        </code><code></code></td>
    </tr>
  </table>

  <p>RDFS does not partition the universe into disjoint categories of classes, properties and individuals.
    Anything in the universe can be used as a class or as a property, or both,
    while retaining its status as an individual which may be in classes and have properties.
    Thus, RDFS permits classes which contain other classes, classes of properties, properties of classes, etc.
    As the axiomatic triples above illustrate, it also permits classes which contain themselves and properties
    which apply to themselves.
    A property of a class is not necessarily a property of its members, nor vice versa.</p>

  <section id="rdfs_literal_note" class="informative">
    <h4>A note on rdfs:Literal</h4>

    <p>The class <code>rdfs:Literal</code> is not the class of literals,
      but rather that of literal values, which may also be denoted by IRIs.
      For example, LV does not contain the literal <code>"foodle"^^xsd:string</code>
      but it does contain the string "foodle".</p>

    <p>A triple of the form</p>

    <p><code>ex:a rdf:type rdfs:Literal .</code></p>

    <p>is consistent even though its subject is an IRI rather
      than a literal. It says that the IRI '<code>ex:a</code>'
      <a>denotes</a> a literal value, which is quite possible since literal values are things in the universe.
      Blank nodes may range over literal values, for the same reason.</p>

  </section>

  <section id="rdfs_entailment">
    <h3>RDFS entailment</h3>

    <p>S <dfn>RDFS entails</dfn> E <strong>recognizing D</strong> when every <a>RDFS interpretation</a> recognizing D
      which <a>satisfies</a> S also satisfies E.</p>

    <p> Since every <a>RDFS interpretation</a> is an <a>RDF interpretation</a>,
      if S <a>RDFS entails</a> E then S also <a>RDF entail</a>s E;
      but RDFS entailment is stronger than RDF entailment.
      Even the empty graph has a large number of RDFS entailments which are not RDF entailments,
      for example all triples of the form </p>

    <p> aaa <code>rdf:type rdfs:Resource .</code></p>

    <p>where aaa is an IRI, are true in all RDFS interpretations.</p>

    <section id="rdfs_patterns" class="informative" data-dfn-for="RDFS entailment patterns">
      <h4>Patterns of RDFS entailment</h4>

      <P>RDFS entailment holds for all the following patterns, 
        which correspond closely to the RDFS semantic conditions:</p>

      <table id="rdfs_entailment_patterns">
        <caption>RDFS entailment patterns.</caption>
        <tbody>
          <tr >
            <th ></th>
            <th >If S contains:</th>
            <th >then S RDFS <a>entails recognizing D</a>:</th>
          </tr>
          <tr >
           <td class="othertable"><dfn>rdfs1</dfn></td>
           <td class="othertable">any IRI aaa in D</td>
           <td class="othertable">aaa <code>rdf:type rdfs:Datatype . </code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs2</dfn></td>
            <td class="othertable"> aaa <code>rdfs:domain</code> xxx <code>.</code><br />
                yyy aaa zzz <code>.</code></td>
            <td class="othertable">yyy <code>rdf:type</code> xxx <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs3</dfn></td>
            <td class="othertable">aaa <code>rdfs:range</code> xxx <code>.</code><br />
                yyy aaa zzz <code>.</code></td>
            <td class="othertable">zzz <code>rdf:type</code> xxx <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs4</dfn></td>
            <td class="othertable">Any triple ttt such that xxx <a>appears in</a> ttt</td> 
            <td class="othertable">xxx <code>rdf:type rdfs:Resource .</code>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs5</dfn></td>
            <td class="othertable"> xxx <code>rdfs:subPropertyOf</code> yyy <code>.</code><br />
                yyy <code>rdfs:subPropertyOf</code> zzz <code>.</code></td>
            <td class="othertable">xxx <code>rdfs:subPropertyOf</code> zzz <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs6</dfn></td>
            <td class="othertable">xxx <code>rdf:type rdf:Property .</code></td>
            <td class="othertable">xxx <code>rdfs:subPropertyOf</code> xxx <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs7</dfn></td>
            <td class="othertable"> aaa <code>rdfs:subPropertyOf</code> bbb <code>.</code><br />
                xxx aaa yyy <code>.</code></td>
            <td class="othertable">xxx bbb yyy <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs8</dfn></td>
            <td class="othertable">xxx <code>rdf:type rdfs:Class .</code></td>
            <td class="othertable">xxx <code>rdfs:subClassOf rdfs:Resource .</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs9</dfn></td>
            <td class="othertable">xxx <code>rdfs:subClassOf</code> yyy <code>.</code><br />
                zzz <code>rdf:type</code> xxx <code>.</code></td>
            <td class="othertable">zzz <code>rdf:type</code> yyy <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs10</dfn></td>
            <td class="othertable">xxx <code>rdf:type rdfs:Class .</code></td>
            <td class="othertable">xxx <code>rdfs:subClassOf</code> xxx <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs11</dfn></td>
            <td class="othertable"> xxx <code>rdfs:subClassOf</code> yyy <code>.</code><br />
                yyy <code>rdfs:subClassOf</code> zzz <code>.</code></td>
            <td class="othertable">xxx <code>rdfs:subClassOf</code> zzz <code>.</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs12</dfn></td>
            <td class="othertable">xxx <code>rdf:type rdfs:ContainerMembershipProperty .</code></td>
            <td class="othertable">xxx <code>rdfs:subPropertyOf rdfs:member .</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs13</dfn></td>
            <td class="othertable">xxx <code>rdf:type rdfs:Datatype .</code></td>
            <td class="othertable">xxx <code>rdfs:subClassOf rdfs:Literal .</code></td>
          </tr>
          <tr >
            <td class="othertable"><dfn>rdfs14</dfn></td>
            <td class="othertable">Any triple ttt such that &lt;&lt;(aaa bbb ccc)&gt;&gt; <a>appears in</a> ttt</td>
            <td class="othertable">ttt [&lt;&lt;(aaa bbb ccc)>>/_:nnn]<br/>
            _:nnn <code>rdf:type rdfs:Proposition .</code></td>
          </tr>
        </tbody>
      </table>
      <p>As an example of a RDFS entailment involving triple terms using the entailment pattern rdfs14,
        the graph below RDFS entails the triples that follow:</p>

      <p><code>ex:a ex:b &lt;&lt;( ex:c ex:d &lt;&lt;(ex:e ex:f ex:g)>> )>> .</code></p>

      <p><code>ex:a ex:b &lt;&lt;( ex:c ex:d _:b1 )>> .<br/>
               ex:a ex:b _:b2 .<br/>
               _:b1 rdf:type rdfs:Proposition .<br/>
               _:b2 rdf:type rdfs:Proposition .</code></p>

      <p>RDFS provides several new ways to be <a>unsatisfiable</a> recognizing D.
        For example, the following graph is RDFS unsatisfiable recognizing {<code>xsd:integer</code>, <code>xsd:boolean</code>}:</p>

      <p><code>ex:p rdfs:domain xsd:boolean .<br/>
        ex:a rdf:type xsd:integer .<br/>
        ex:a ex:p ex:c .</code></p>

    </section>
  </section>
</section>

<section id="rdf_datasets">
  <h2>RDF Datasets</h2>

  <p><a>RDF datasets</a>,
    defined in RDF Concepts [[!RDF12-CONCEPTS]],
    package up zero or more named RDF graphs along with a single unnamed, default RDF graph.
    The graphs in a single dataset may share blank nodes.
    SPARQL [[?SPARQL12-QUERY]] associates graph names with graphs
    to allow queries to be directed against particular graphs.</p>

  <p>Graph names in a dataset may denote something other than the graph they are paired with.
    This allows IRIs or blank nodes denoting other kinds of entities, such as persons,
    to be used in a dataset to <a>identify</a> graphs of information relevant to the entity <a>denoted</a> by the graph name.</p>

  <p>When a graph name is used inside RDF triples in a dataset it may or may not denote the graph it names.
    The semantics does not require, nor should RDF engines presume,
    without some external reason to do so, that graph names used in RDF triples denote the graph they name.</p>

  <p>RDF datasets MAY be used to express RDF content.
    When used in this way, a dataset SHOULD be understood to have at least the same content as its default graph.
    Note however that replacing the default graph of a dataset by a logically equivalent graph
    will not in general produce a structurally similar dataset,
    since it may for example disrupt co-occurrences of blank nodes between the default graph and other graphs in the dataset,
    which may be important for reasons other than the semantics of the graphs in the dataset.</p>

  <p>Other <a>semantic extension</a>s and <a>entailment regime</a>s MAY place further semantic conditions and restrictions on RDF datasets,
    just as with RDF graphs.
    One such extension, for example, could set up a modal-like interpretation structure so that entailment
    between datasets would require RDF graph entailments between the graphs with the same <a>name</a>
    (adding in empty graphs as required).</p>

  <table>
    <caption>Definition of an RDF dataset</caption>
    <tr>
       <td class="semantictable">
       <p>An <a>RDF dataset</a>
	      is a set:<br/>
              { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . .
              . (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }<br>
              where n&ge;0, G and each G<sub>i</sub> are graphs, and each &lt;u<sub>i</sub>&gt; is an IRI or blank node. Each
              &lt;u<sub>i</sub>&gt; is distinct.</p>
            <p>G is called the default graph. (&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) are called named
              graphs.</p>
        </td>
    </tr>
  </table>

  <table>
    <caption>Definition of RDF dataset merge</caption>
    <tr>
       <td class="semantictable">
            <p>Let DS1 = { G1, (&lt;u1<sub>1</sub>&gt;, G1<sub>1</sub>), (&lt;u1<sub>2</sub>&gt;,
              G1<sub>2</sub>), . . . (&lt;u1<sub>n</sub>&gt;, G1<sub>n</sub>) },<br>
              and DS2 = { G2, (&lt;u2<sub>1</sub>&gt;, G2<sub>1</sub>), (&lt;u2<sub>2</sub>&gt;,
              G2<sub>2</sub>), . . . (&lt;u2<sub>m</sub>&gt;, G2<sub>m</sub>) }</p>
            <p>The <dfn>RDF dataset merge</dfn> of DS1 and DS2 is:<br>
              DS={ G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), .
              . . (&lt;u<sub>k</sub>&gt;, G<sub>k</sub>) }<br>
              where:</p>
            <p>Write N1 for { &lt;u1<sub>j</sub>&gt; j = 1 to n }<br>
              Write N2 for { &lt;u2<sub>j</sub>&gt; j = 1 to m }<br></p>
            <ul>
              <li>G is the <a>merge</a> of G1 and G2
              </li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N1 but not
                in N2</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N2 but not
                in N1</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is equal to
                &lt;u<sub>j</sub>&gt; in N1 and equal to &lt;u<sub>k</sub>&gt; in N2 and G<sub>i</sub>
                is the <a>merge</a> of G1<sub>j</sub> and G2<sub>k</sub>
              </li>
            </ul>
        </td>
    </tr>
  </table>

</section>

<h2 id="appendices">Appendices</h2>

<section id="entailment_rules" class="informative appendix">
  <h2>Entailment rules</h2>

<p> <em> Note: This section is carried over from RDF 1.1 and is included here to show how sound and complete inference rules might be constructed for the current versions of RDF and RDFS.  It is believed that at most minor changes to the entailment rules here will be needed for sound and complete RDF and RDFS entailment. </em> </p>


  <p>(<em>This section is based on work described more fully in two papers by ter Horst, </em>[[HORST04]]<em> and </em>[[HORST05]]<em>,
    which should be consulted for technical details and proofs.</em>) </p>

  <p>The RDF and RDFS entailment patterns listed in the above tables can be viewed
    as left-to-right rules which add the entailed conclusion to a graph.
    These rule sets can be used to check RDF (or RDFS) entailment between graphs S and E,
    by the following sequence of operations:</p>

  <ol>
    <li>Add to S all the RDF (or RDF and RDFS) axiomatic triples except those containing the container membership property IRIs <code>rdf:_1, rdf:_2, ...</code></li>
    <li>For every container membership property IRI which occurs in E, add the RDF (or RDF and RDFS) axiomatic triples which contain that IRI.</li>
    <li>For every IRI <code>aaa</code> used in E, add <code>aaa rdf:type rdfs:Resource</code> to S.</li>
    <li>Apply the RDF (or RDF and RDFS) inference patterns as rules, adding each conclusion to the graph, to exhaustion; that is, until they generate no new triples.</li>
    <li>Determine if E has an instance which is a subset of the set, i.e., whether the enlarged set <a>simply entails</a> E.</li>
  </ol>

  <p>This process is clearly correct, in that if it gives a positive result then indeed S does RDF (RDFS) entail E.
    It is not, however, complete: there are cases of S entailing E which are not detectable by this process. Examples include:</p>

  <table>
    <thead>
      <tr>
        <th> </th>
        <th>RDF entails</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="othertable"><code>ex:a ex:p "string"^^xsd:string .<br/>
          ex:b ex:q "string"^^xsd:string .</code></td>
        <td class="othertable"><code>ex:a ex:p _:b .<br/>
          ex:b ex:q _:b .<br/>
          _:b rdf:type xsd:string .</code> </td>
      </tr>

      <tr>
        <th> </th>
        <th>RDFS entails</th>
      </tr>

      <tr>
        <td class="othertable"><code>ex:a rdfs:subPropertyOf _:b .<br/>
          _:b rdfs:domain ex:c .<br/>
          ex:d ex:a ex:e .</code></td>
       <td class="othertable"><code>ex:d rdf:type ex:c .</code> </td>
      </tr>

      <tr>
        <th> </th>
        <th>RDFS entails</th>
      </tr>

      <tr>
        <td class="othertable"><code>ex:a ex:b ex:c .</code></td>
       <td class="othertable"><code>&lt;&lt;(ex:a ex:b ex:c)>> rdf:type rdfs:Proposition .</code> </td>
      </tr>
    </tbody>
  </table>

  <p>These examples can be handled by allowing the rules to apply to a generalization of the RDF syntax
    in which literals and triple terms may occur in subject position and blank nodes may occur in predicate position.</p>

  <!--<p>Define a <dfn>generalized RDF triple</dfn> to be a triple &lt;x, y, z&gt; where x and z can be an IRI, a blank node or a literal, and y can be an IRI or a blank node; and extend this to the rest of RDF, so that a generalized RDF graph is a set of generalized RDF triples. -->

  <p>Consider <a data-cite="RDF12-CONCEPTS#section-generalized-rdf">generalized RDF triples, graphs, and datasets</a>
    instead of RDF triples, graphs and datasets (extending the generalization used by Horst [[HORST04]]
    and following exactly the terms used in OWL Profiles [[OWL2-PROFILES]]).
    The semantics described in this document applies to the generalization without change,
    so that the notions of interpretation, satisfiability and entailment can be used freely.
    Then we can replace the first RDF entailment pattern with the simpler and more direct</p>

  <table>
    <caption>G-RDF-D entailment pattern.</caption>
    <tbody>
      <tr>
        <th > </th>
        <th ><strong>if S contains</strong></th>
        <th ><strong>then S RDF entails, recognizing D</strong></th>
      </tr>
      <tr >
        <td class="othertable"><dfn>GrdfD1</dfn></td>
        <td class="othertable"> Any triple ttt such that <code>"</code>sss<code>"^^</code>ddd appears in ttt
            for ddd in D</td>
        <td class="othertable"><code>"</code>sss<code>"^^</code>ddd <code>rdf:type</code> ddd <code>.</code></td>
     </tr>
    </tbody>
  </table>

  <p> which gives the entailments;</p>

  <p><code>ex:a ex:p "string"^^xsd:string .<br/>
    ex:b ex:q "string"^^xsd:string .<br/>
    "string"^^xsd:string rdf:type xsd:string .</code>  by <a>GrdfD1</a></p>

  <p>which is an instance (in generalized RDF) of the desired conclusion, above.</p>
  <p> The second example can be derived using the RDFS rules:</p>
  <p><code>ex:a rdfs:subPropertyOf _:b .<br/>
    _:b rdfs:domain ex:c .<br/>
    ex:d ex:a ex:e .<br/>
    ex:d _:b ex:c .</code>  by <a>rdfs7</a><br/>
    <code>ex:d rdf:type ex:c .</code> by <a>rdfs2</a></p>

  <p>Where the entailment patterns have been applied to generalized RDF syntax but yield a final conclusion which is legal RDF.</p>

  <p>With the generalized syntax, these rules are postulated to be complete for both RDF and RDFS entailment. Stated exactly:</p>

  <p>Let S and E be RDF graphs. Define the <dfn>generalized RDF (RDFS) closure</dfn> <strong>of S towards E</strong>
    to be the set obtained by the following procedure.</p>

  <ol>
    <li>Add to S all the RDF (and RDFS) axiomatic triples which do not contain any container membership property IRI.</li>
    <li>For each container membership property IRI which occurs in E, add the RDF (and RDFS) axiomatic triples which contain that IRI.</li>
    <li>If no triples were added in step 2, add the RDF (and RDFS) axiomatic triples which contain <code>rdf:_1</code>.</li>
    <li>For every IRI or literal <code>aaa</code> used in E, add <code>aaa rdf:type rdfs:Resource</code> to S.</li>
    <li>Apply the rules <a>GrdfD1</a>, <a>rdfD1a</a>, and <a>rdfD2</a> (and the rules <a>rdfs1</a> through <a>rdfs13</a>),
      with D={<code>rdf:langString</code>, <code>rdf:dirLangString</code>, <code>xsd:string</code>},
      to the set in all possible ways, to exhaustion.</li>
  </ol>

  <p>If these rules are complete, they would give rise to the following completeness result:</p>

  <p class="postulate">If S is RDF consistent (RDFS consistent), then S RDF entails (RDFS entails) E just
    when the <a>generalized RDF (RDFS) closure</a> of S towards E <a>simply entails</a> E. </p>

  <p>The closures are finite. The generation process is decidable and of polynomial complexity.
    Detecting simple entailment is NP-complete in general, but of low polynomial order when E contains no blank nodes.</p>

  <p>Every RDF(S) closure, even starting with the empty graph,
    will contain all RDF(S) tautologies which can be expressed using the vocabulary of the original graph
    plus the RDF and RDFS vocabularies.
    In practice there is little utility in re-deriving these,
    and a subset of the rules can be used to establish most entailments of practical interest.</p>

  <p>If it is important to stay within legal RDF syntax, rule <a>rdfD1</a> may be used instead of <a>GrdfD1</a>,
    and the introduced blank node can be used as a substitute for the literal in subsequent derivations.
    The resulting set of rules will not however be complete.</p>

  <p>As noted earlier, detecting datatype entailment for larger sets of datatype IRIs
    requires attention to idiosyncratic properties of the particular datatypes.</p>
    
  <p>
  The entailment pattern for generalized RDF with [=symmetric RDF triples=],
  considering that, according to the semantics, the denotation of triple terms should
  be of type <code>rdfs:Proposition</code>, is the following:
  </p>
    <table>
    <caption>RDFS-T entailment pattern.</caption>
    <tbody>
      <tr>
        <th > </th>
        <th ><strong>if S contains</strong></th>
        <th ><strong>then S RDFS entails</strong></th>
      </tr>
      <tr >
        <td class="othertable"><dfn>Grdfs14</dfn></td>
        <td class="othertable">xxx <code>rdf:type rdfs:Resource .</code><br/>
        yyy <code>rdf:type rdf:Property .</code><br/>
        zzz <code>rdf:type rdfs:Resource .</code><br/>
        </td>
        <td class="othertable"><code>&lt;&lt;(xxx yyy zzz)>> rdf:type rdfs:Proposition .</code></td>
      </tr>
    </tbody>
    </table>
  

</section>

<section id="proofs" class="informative appendix">
  <h2>Proofs of some results</h2>

  <p class="issue" data-number="102">These claims still need to be checked.</p>

  <p class="fact"> The <a>empty graph</a> is simply entailed by
    any graph, and does not simply entail any graph except itself.
  <!-- <a href="#emptygraphlemmaprf" class="termref">[Proof]</a> -->
  </p>

  <p>The empty graph is true in all simple interpretations, so is entailed by any graph.
    If G contains a triple &lt;a b c&gt;, then any simple interpretation I with IEXT(I(b))={ } makes G false;
    so the empty graph does not entail G. QED.</p>

  <p class="fact"> A graph <a>simply entails</a> all its <a>subgraphs</a>.
  <!-- <a href="#subglemprf" class="termref">[Proof]</a> -->
  </p>

  <p>If I <a>satisfies</a> G then it satisfies every triple in G, hence every triple in any subset of G. QED.</p>

  <p class="fact"> A graph
    is simply entailed by any of its <a>instance</a>s.
  <!-- <a href="#instlemprf" class="termref"> [Proof]</a> -->
  </p>

  <p>Suppose H is an instance of G with the instantiation mapping M, and that I <a>satisfies</a> H.
    For blank nodes n in G which are not in H define A(n)=I(M(n)); then I+A satisfies G, so I satisfies G. QED.</p>

  <p class="fact">Every graph is simply <a>satisfiable</a>.</p>

  <p>Consider the simple interpretation with universe {x}, IEXT(x)= &lt;x,x &gt; and I(aaa)=x for any IRI aaa. This interpretation satisfies every RDF graph. QED.</p>

  <p class="fact">
    G <a>simply entails</a> a graph E if and only if a <a>subgraph</a> of G is an instance of E.
  </p>

  <p>If a <a>subgraph</a> E' of G is an instance of E then G entails E' which entails E,
    so G entails E. Now suppose G entails E, and consider the
    <a href="http://en.wikipedia.org/wiki/Herbrand_interpretation">Herbrand interpretation</a> I of G defined as follows.
    IR contains the <a>names</a> and blank nodes which occur in the graph, with I(n)=n
    for each <a>name</a> n; n is in IP and &lt;a, b&gt; in IEXT(n) just when the triple &lt;a n b&gt; is in the graph.
    (For IRIs which do not occur in the graph, assign them values in IR at random.)
    I <a>satisfies</a> every triple &lt;s p o&gt; in E; that is,
    for some mapping A from the blank nodes of E to the vocabulary of G,
    the triple &lt;[I+A](s) I(p) [I+A](o)&gt; occurs in G. But this is an instance of &lt;s p o&gt;
    under the instance mapping A; so an instance of E is a <a>subgraph</a> of G. QED.</p>

  <p class="fact">if E is lean and E' is a proper instance of E, then E does not simply entail E'.</p>

  <p>Suppose E entails E', then a <a>subgraph</a> of E is an instance of E', which is a proper instance of E;
    so a <a>subgraph</a> of E is a proper instance of E, so E is not lean. QED.</p>

  <p class="fact">If E contains an IRI which does not occur in S, then S does not simply entail E.</p>

  <p>IF S entails E then a <a>subgraph</a> of S is an instance of E,
    so every IRI in E must occur in that <a>subgraph</a>,
    so must occur in S. QED.</p>

  <p class="fact">For any graph H, if sk(G) <a>simply entails</a> H then there is a graph H'
    such that G entails H' and H=sk(H').</p>

  <p>The skolemization mapping sk substitutes a unique new IRI for each blank node,
    so it is 1:1, so has an inverse. Define ks to be the inverse mapping
    which replaces each skolem IRI by the blank node it replaced.
    Since sk(G) entails H, a <a>subgraph</a> of sk(G) is an instance of H,
    say A(H) for some instance mapping A on the blank nodes in H.
    Then ks(A(H)) is a <a>subgraph</a> of G; and ks(A(H))=A(ks(H)) since
    the domains of A and ks are disjoint.
    So ks(H) has an instance which is a <a>subgraph</a> of G,
    so is entailed by G; and H=sk(ks(H)). QED.</p>

  <p class="fact">For any graph H which does not contain any of the "new" IRIs introduced into sk(G),
    sk(G) <a>simply entails</a> H if and only if G <a>simply entails</a> H.</p>

  <p>Using the terminology in the previous proof: if H does not contain any skolem IRIs, then H=ks(H).
    So if sk(G) entails H then G entails ks(H)=H; and if G entails H then sk(G) entails G entails H, so sk(G) entails H. QED.</p>

</section>

<section id="privacy" class="informative appendix">
  <h2>Privacy Considerations</h2>
  <p>
    See <a data-cite="RDF12-CONCEPTS#privacy">Privacy Considerations</a> in [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]].
  </p>
</section>
<section id="security" class="informative appendix">
  <h2>Security Considerations</h2>
  <p>
    See <a data-cite="RDF12-CONCEPTS#security">Security Considerations</a> in [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]].
  </p>
</section>

<section id="Acknowledgments" class="informative appendix" >
  <h2>Acknowledgments</h2>

    <p>In addition to the editors, the following people have contributed to the RDF 1.2 version:
      <span id="gh-contributors"></span>
    </p>

    <p data-include="common/participants.html"></p>

  <p>The basic idea of using an explicit extension mapping to allow self-application without
    violating the axiom of foundation was suggested by Christopher Menzel.
    The generalized RDF syntax used in <a href="#entailment_rules" class="sectionRef"></a>,
    and the example showing the need for it, were suggested by Herman ter Horst,
    who also proved completeness and complexity results for the rule sets of RDF 1.1.
    Jeremy Carroll first showed that simple entailment is NP-complete in general.
    Antoine Zimmerman suggested several simplifications and improvements to the proofs and presentation.</p>

  <p>The RDF 1.1 editors acknowledge valuable contributions from Thomas Baker, Dan Brickley, Gavin Carothers,
    Jeremy Carroll, Pierre-Antoine Champin, Richard Cyganiak, Martin J. DÃ¼rst, Alex Hall, Steve Harris, Ivan Herman,
    Eric Prud'hommeaux, Andy Seaborne, David Wood and Antoine Zimmermann. </p>

  <p>This specification draws upon the
    earlier specification for RDF semantics [[RDF-MT]], whose editor acknowledged valuable
    inputs from  Jeremy Carroll, Dan Connolly, Jan Grant, R. V. Guha,
    Herman ter Horst, Graham Klyne, Ora Lassila, Brian McBride, Sergey
    Melnick, Peter Patel-Schneider, Jos De Roo and Patrick Stickler. 
    Brian McBride was the series editor for this earlier specification.</p>

</section>

<section id="section-Changes" class="informative appendix">
  <h2>Substantive Changes</h2>

<section id="ChangeLog-11" class="informative appendix" >
  <h2>Substantive changes between RDF 1.0 and RDF 1.1 </h2>

<ul>

 <li>
    The RDF 1.0 semantics defined simple interpretations relative to a vocabulary.
  </li>

  <li>
    In the RDF 1.0 semantics, IL was a total, rather than partial, mapping.
  </li>
  
  <li> The RDF 1.0 specification divided literals into 'plain' literals
      with no type and optional language tags, and typed literals.
      Usage has shown that it is important that every literal have a type.
      RDF 1.1 replaced plain literals without language tags by literals typed with
      the XML Schema <code>string</code> datatype,
      and introduced the special type
      <a data-cite="RDF12-CONCEPTS#dfn-language-tagged-string"><code>rdf:langString</code></a>
      for language-tagged strings.
      The full semantics for typed literals is given in Section [[[#datatypes]]].
  </li>

  <li>In the RDF 1.0 specification
    datatype D-entailment was defined as a <a>semantic extension</a> of RDFS-entailment.
    In RDF 1.1 it was defined as a direct extension to basic RDF.
    This is more in conformity with actual usage,
    where RDF with datatypes is widely used without the RDFS vocabulary.
    If there is a need to differentiate from the RDF 1.0 terminology,
    the longer phrasing "simple D-entailment" or "simple datatype entailment"
    should be used rather than "D-entailment".
  </li>

  <li>RDF 1.0 specification defined the parameter D
    as a <a>datatype map</a> from IRIs to datatypes,
    i.e., as a restricted kind of interpretation mapping.
    As RDF 1.1 presumed that a recognized IRI identifies a unique datatype,
    this IRI-to-datatype mapping is globally unique and externally specified,
    so we can think of D as either a set of IRIs or as a fixed <a>datatype map</a>.
    Formally, the <dfn>datatype map</dfn> corresponding to the set D is the
    restriction of a <a>D-interpretation</a> to the set D.
    Semantic extensions which are stated in terms of conditions on <a>datatype maps</a>
    can be interpreted as applying to this mapping.
  </li>


  <li>In the RDF 1.0 specification,
      ill-typed literals were required to denote a value in IR,
    and <a>D-unsatisfiability</a> could be recognized only by using the RDFS semantics.
  </li>

  <li>In the 2004 RDF 1.0 semantics, LV was defined as part of a simple interpretation structure,
    and its definition in RDFS interpretations was a constraint. 
  </li>

</ul>

</section>

<section id="ChangeLog-12" class="informative appendix" >
  <h2>Substantive changes since RDF 1.1</h2>

  <ul>
    <li> The major change between the RDF 1.1 and RDF 1.2 semantics is the addition of triple terms.
      Various parts of the semantics have been updated to handle triple terms.
    </li>

    <li> RDF entailment rule <a>rdfD1a</a> was added in RDF 1.2.  
      This rule should have been included in RDF 1.1 when the two built-in
      datatypes (<code>xsd:string</code> and <code>rdf:langString</code>)
      were added to RDF entailment.
    </li>

    <li><code>rdf:dirLangString</code> was added to the built-in datatypes.</li>

    <li>
      In RDF 1.1, <code>rdf:PlainLiteral</code> was described as an optional datatype
      that, "[if] [recognized](https://www.w3.org/TR/rdf11-mt/#dfn-recognize), ...
      MUST be interpreted to [denote] the datatype defined in [[[RDF-PLAIN-LITERAL]]] [[RDF-PLAIN-LITERAL]]."
      <code>rdf:PlainLiteral</code> is not used elsewhere in the RDF documents,
      so the requirement to give it this particular semantics has been removed.
      It is recommended that <code>rdf:PlainLiteral</code> not be used in RDF.
    </li>

    <li> <span id="whatnot"></span> <span id="non_semantics"></span> <span id="Reif"></span> <span id="containers"></span> <span id="collections"></span> <span id="rdf-collections"></span>
      The appendix on RDF reification, containers, and collections has been removed because it had no semantic content.
      The vocabulary involved is described in the
      <a href="https://www.w3.org/TR/rdf12-schema/#ch_legacyvocab">Legacy Vocabularies</a>
      and <a href="https://www.w3.org/TR/rdf12-schema/#ch_collectionvocab">RDF Collections</a>
      sections of RDF Schema.
    </li>

  </ul>


</section>

</section>


<section id="index"></section>

</body></html>
